<!DOCTYPE html>
<html lang="en-us">

<head>
	<title>游戏设计</title>
	<meta charset="utf-8" />
	<meta name="description" content="游戏设计 tutorials">
	<meta name="keywords" content="游戏设计">
	<meta name="author" content="LaoZhang">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="styles.css" />
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>
	<script type="text/javascript" async
		src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js">
	</script>
	<style>
		li.L0,
		li.L1,
		li.L2,
		li.L3,
		li.L5,
		li.L6,
		li.L7,
		li.L8 {
			list-style-type: decimal !important;
		}
	</style>
</head>

<body>

	<p align="right">制心一处</p>
	<hr />

<h1>ufw</h1>
<ol>
	<li>ufw status verbose</li>
	<li>ufw enable</li>
	<li>ufw disable</li>
	<li>ufw allow 5000</li>
	ufw allow 5000:5010/tcp

	ufw allow from 10.0.0.1 to any port 22

	<li>delete</li>
	ufw status numbered

	ufw delete [that number]
</ol>

	<h1>vscode</h1>
	<ol>
		<li>install-package</li>
		dotnet add package Newtonsoft.Json
	</ol>
	<h1>vim</h1>
	<ol>
		<li>copy the whole line</li>
		yy

		<li>past</li>
		p

		<li>open file/directory</li>
		:e file/directory name

		<li>enter insert mode</li>
		i

		<li>switch insert model to normal mode</li>
		esc

		<li>split screen</li>
		:vs filename
		:sp filename
		switch cursor: ctrl+w w

		<li>多文件切换</li>
		:bn
		:bp




	<h1>如何在家里ssh远程访问公司局域网内电脑</h1>
	<ol>
		<ul>
			<li>A机公司局域网</li>
			<li>B机公网linux主机</li>
			<li>C机家里的notebook</li>
		</ul>
		<li>A机</li>
		luther@gliethttp:~$ ssh -CfNg -R 7001:localhost:22     用户名@B机
		
		<li>C机</li>
		luther@gliethttp:~$ ssh -CfNg -L 7000:localhost:7001   用户名@B机

		<li>C机</li>
		luther@gliethttp:~$ ssh -p 7000 A机用户名@localhost    就可以登录公司的A机了

		<li>C机</li>
		luther@gliethttp:~$ ssh -X -p 7000 A机用户名@localhost 就可以执行A机上的图形程序了,比如nautilus .

	</ol>

	<h1>deplay dotnet core on Linux</h1>
	<ol>
		<li>sudo apt install aspnetcore-runtime-3.1</li>
		
		<li>dotnet Login.dll --urls=http:[::]:5001</li>
		<li>复制到PATH</li>
		sudo mv cheat-linux-amd64.gz /usr/bin/cheat
		<li>测试</li>
		cheat tar
	</ol>

	<h1>cheat</h1>
	<ol>
		<li>下载</li>
		wget https://github.com/cheat/cheat/releases/download/4.0.1/cheat-linux-amd64.gz
		<li>解压</li>
		<li>复制到PATH</li>
		sudo mv cheat-linux-amd64.gz /usr/bin/cheat
		<li>测试</li>
		cheat tar
	</ol>

	<h1>网络</h1>
	<ol>
		<li>netstat</li>
		sudo netstat -tulpn

		<li>端口占用</li>
		sudo netstat -tunlp | grep 80
	</ol>

	<h1>nginx</h1>
	<ol>
		<li>install</li>
		sudo apt install nginx
		<li>start</li>
		sudo systemctl start nginx
		<li>stop</li>
		sudo systemctl stop nginx
		<li>restart</li>
		sudo systemctl restart nginx
		<li>status</li>
		sudo systemctl status nginx
		<li>reload</li>
		sudo systemctl reload nginx

		<li>master进程 & worker进程</li>
		1个master进程，N个worker进程
		nginx -s signal
		stop — fast shutdown
		quit — graceful shutdown
		reload — reloading the configuration file
		reopen — reopening the log files

		<li>/var/etc/nginx/nginx.conf</li>
		http{
			server{
				listen 80;

				location / {
					/var/www/html
				}
			}
		}

		<li>日志</li>
		access.log and error.log 
		/usr/local/nginx/logs or /var/log/nginx
	</ol>

	<h1>进程</h1>
	<ol>
		<li>process search</li>
		ps aux | grep 'redis'
		<li>所有进程内存、cpu使用情况</li>
		top
		htop
		退出：q
		帮助: h
		<li>kill</li>
		sudo kill 643
	</ol>

	<h1>内存</h1>
	RAM: Random Access Memory
	<ol>
		<li>总体内存使用情况</li>
		free -m
		<li>swamp space</li>
		vmstat
		<li></li>
		less /proc/meminfo
		less /proc/cpuinfo
	</ol>

	<h1>硬盘</h1>

	<ol>
		<li>disk free</li>
		// 默认block单位K
		df
		// block 单位G
		df -BG
		// human readable
		df -h

		<li>swamp space</li>
		vmstat
		<li></li>
		less /proc/meminfo
		less /proc/cpuinfo
	</ol>

	<h1>StackExchange.Redis</h1>
	<ol>
		<li>connect & get</li>
		<pre class="prettyprint">
var redis = ConnectionMultiplexer.Connect("172.18.0.3:6379,password=Euler2019");
IDatabase db = redis.GetDatabase();
string value = db.StringGet("name");
Console.WriteLine(value);
	</pre>

		<li>pub/sub message</li>
		<pre class="prettyprint">
var redis = ConnectionMultiplexer.Connect("172.18.0.3:6379,password=Euler2019");
ISubscriber sub = redis.GetSubscriber();
sub.Subscribe("messages", (channel, message) =>
{
	Console.WriteLine($"{channel}:{message}");
});
// Synchronous handler
sub.Subscribe("messages").OnMessage(channelMessage =>
{
	Console.WriteLine($"1:{channelMessage.Message}");
});
// Asynchronous handler
sub.Subscribe("messages").OnMessage(async channelMessage =>
{
	await Task.Delay(1000);
	Console.WriteLine($"2:{channelMessage.Message}");
});
sub.Publish("messages", "hello");
	</pre>
		<li>await</li>
		<pre class="prettyprint">
string value = "abcdefg";
await db.StringSetAsync("mykey", value);
...
string value = await db.StringGetAsync("mykey");
Console.WriteLine(value); // writes: "abcdefg"
	</pre>

		<li>fire-and-forgot</li>
		<pre class="prettyprint">
db.StringIncrement(pageKey, flags: CommandFlags.FireAndForget);
	</pre>
	</ol>

	<h1>redis</h1>
	REmote DIctionary Server
	<ol>
		<li>install</li>
		sudo apt install redis

		<li><a href="https://www.learn2torials.com/a/how-to-uninstall-redis-server-from-ubuntu">uninstall</a></li>
		<li>check version</li>
		redis-cli --version

		<li>check status</li>
		sudo systemctl status redis

		q键退出
		<li>start</li>
		sudo systemctl start redis-server

		<li>stop</li>
		sudo systemctl stop redis

		<li>redis-cli</li>
		redis-cli -h localhost -p 6379 -a 'Euler2019'
		set name euler
		get name

		<li>stop</li>
		redis-cli shutdown nosave

		<li>message broker</li>
		send: rpush
		receive: blpop

		<li>password</li>
		requirepass Euler2019
	</ol>

	<hr />
	<h1>tmux</h1>
	<ol>
		<li>install</li>
		sudo apt install tmux

		<li>new unnamed session</li>
		tmux

		<li>new named session</li>
		tmux new -s GameServer

		<li>create new window</li>
		ctrl+b c

		<li>list all sessions</li>
		//tmux session模式内
		ctrl+b s
		//不在tmux session模式内
		tmux ls

		<li>list all windows of all sessions</li>
		ctrl+b w

		<li>不同的用户，登录同一个session的同一个window，可以同步屏幕</li>

		<li>detach session</li>
		ctrl+b d

		<li>attach session</li>
		tmux attach-session -t mysessionname

		// attach last session
		tmux a

		<li>kill session</li>
		tmux kill-session

		<li>panel：切割window</li>
		ctrl+b %
		ctrl+b "
		// flash panel number
		ctrl+b q

		<li>rename session</li>
		tmux rename-session login
		ctrl+b $
	</ol>

	<hr />
	<h1>fish</h1>
	<ol>
		<li>install</li>
		sudo apt install fish
		<li>auto suggestion</li>
		accept all: right arrow
		accept one word: ctrl + right arrow
	</ol>

	<hr />
	<h1>ubuntu</h1>
	龙归大海，最终还是步入linux，原因很现实：运维便利、节省成本
	<ol>
		<li>cpu core查询</li>
		lscpu | less

		<li>下载</li>
		wget https://github.com/cheat/cheat/releases/download/4.0.1/cheat-linux-amd64.gz

		<li>权限控制</li>
		chmod
		三大权限:Read、Write、eXcute
		三类用户:owner、group、others

		<li>copy file</li>
		cp

		<li>move/rename file/directory</li>
		mv

		<li>print system information</li>
		uname

		<li>create directory</li>
		mkdir

		<li>creae a file</li>
		touch test.txt

		<li>帮助文档</li>
		man ls
		// search key word
		man -k fuck

		//
		whatis ls
		//
		whereis ls
		<li>list content of the directory</li>
		ls -l
		// including hiden files
		ls -a
		<li>see file is a file or a directory</li>
		file filename
		<li>linux is case sensitive</li>
		<li>pwd</li>
		print work directory

		<li>hiden file</li>
		.XXX

		<li>打开防火墙端口1022</li>
		iptables -I INPUT -p tcp --dport 1022 -j ACCEP

		<li>升级ubuntu版本</li>
		sudo apt update & sudo apt upgrade & sudo do-release-upgrade

		<li>sql server</li>
		<a
			href="https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-ubuntu?view=sql-server-linux-ver15">sql
			server on linux</a>

		<li>migrate sql server from windows to linux</li>
		first, install sql server tools
		curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
		curl https://packages.microsoft.com/config/ubuntu/19.10/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
		sudo apt-get update
		sudo apt-get install mssql-tools unixodbc-dev
		sudo apt-get update
		sudo apt-get install mssql-tools
		echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
		echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
		source ~/.bashrc

		second, restore
		sqlcmd -S localhost -U SA

		--逐行复制，甚不便
		RESTORE DATABASE Web
		FROM DISK = '/var/opt/mssql/backup/Web.bak'
		WITH MOVE 'Web' TO '/var/opt/mssql/data/Web.mdf',
		MOVE 'Web_Log' TO '/var/opt/mssql/data/Web_Log.ldf'
		GO

		RESTORE DATABASE DS
		FROM DISK = '/var/opt/mssql/backup/DS.bak'
		WITH MOVE 'DS' TO '/var/opt/mssql/data/DS.mdf',
		MOVE 'DS_Log' TO '/var/opt/mssql/data/DS_Log.ldf'
		GO

		RESTORE DATABASE DSLog
		FROM DISK = '/var/opt/mssql/backup/DSLog.bak'
		WITH MOVE 'DSLog' TO '/var/opt/mssql/data/DSLog.mdf',
		MOVE 'DSLog_Log' TO '/var/opt/mssql/data/DSLog_Log.ldf'
		GO
		<li>删除文件</li>
		rm test.txt

		<li>删除文件夹</li>
		sudo rm -r -f testdir

		<li>移动文件夹or重命名文件夹</li>
		mv euler happy

		<li>跨操作系统共享目录</li>
		samba
		sudo apt update
		sudo apt install samba

		sudo ufw allow samba

		设置密码，用户必须是系统用户名，密码与系统用户名登录密码不同
		sudo smbpasswd -a username
		sudo vim /etc/samba/smb.conf


		sudo service smbd restart

		<li><a href="https://www.vim.org/">vim编辑器</a></li>

		<li>sql server </li>
		SQL Server 2019
		Enterprise：HMWJ3-KY3J2-NMVD7-KG4JR-X2G8G
		Enterprise Core：2C9JR-K3RNG-QD4M4-JQ2HR-8468J
		Strandard：PMBDC-FXVM3-T777P-N4FY8-PKFF4
		Web：33QQK-WWQNB-G6T46-C86YB-TX2PH


		SQL Server 2017
		Enterprise：TDKQD-PKV44-PJT4N-TCJG2-3YJ6B
		Enterprise Core：6GPYM-VHN83-PHDM2-Q9T2R-KBV83
		Strandard：PHDV4-3VJWD-N7JVP-FGPKY-XBV89
		Web：WV79P-7K6YG-T7QFN-M3WHF-37BXC


		SQL Server 2016
		Enterprise：MDCJV-3YX8N-WG89M-KV443-G8249
		Enterprise Core：TBR8B-BXC4Y-298NV-PYTBY-G3BCP
		Standard：B9GQY-GBG4J-282NY-QRG4X-KQBCR
		Web：BXJTY-X3GNH-WHTHG-8V3XK-T8243
	</ol>

	<hr />
	<h1>dotnet core 的Task</h1>
	<ol>
		<li>异步特性：Task在线程池异步执行，而非主线程，这样就不会造成主线程阻塞</li>
		<li>适用场合：I/O密集型、UI操作、CPU密集型</li>
		<li>自实现Task方法</li>
		<pre class="prettyprint">
public static Task<int> ReadTask(this Stream stream, byte[] buffer, int offset, int count, object state)
{
	var tcs = new TaskCompletionSource<int>();
	stream.BeginRead(buffer, offset, count, ar =>
	{
		try { tcs.SetResult(stream.EndRead(ar)); }
		catch (Exception exc) { tcs.SetException(exc); }
	}, state);
	return tcs.Task;
}
		</pre>
		<li>Task.Run cpu密集型</li>
		<pre class="prettyprint">
internal Task<Bitmap> RenderAsync(ImageData data, CancellationToken cancellationToken)
{
	  return Task.Run(() =>
	  {
		  var bmp = new Bitmap(data.Width, data.Height);
		  for(int y=0; y < data.Height; y++)
		  {
			  cancellationToken.ThrowIfCancellationRequested();
			  for(int x=0; x < data.Width; x++)
			  {
				  //render pixel [x,y] into bmp
			  }
		  }
		  return bmp;
	  }, cancellationToken);
}
</pre>
		<li>I/O-bound tasks</li>
		<pre class="prettyprint">
public static Task<DateTimeOffset> Delay(int millisecondsTimeout)
{
	TaskCompletionSource<DateTimeOffset> tcs = null;
	Timer timer = null;

	timer = new Timer(delegate
	{
		timer.Dispose();
		tcs.TrySetResult(DateTimeOffset.UtcNow);
	}, null, Timeout.Infinite, Timeout.Infinite);

	tcs = new TaskCompletionSource<DateTimeOffset>(timer);
	timer.Change(millisecondsTimeout, Timeout.Infinite);
	return tcs.Task;
}

public static async Task Poll(Uri url, CancellationToken cancellationToken, IProgress<bool> progress)
{
    while(true)
    {
        await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken);
        bool success = false;
        try
        {
            await DownloadStringAsync(url);
            success = true;
        }
        catch { /* ignore errors */ }
        progress.Report(success);
    }
}
</pre>

		<li>cpu-bound: Task.Run 利用多核</li>
		<pre class="prettyprint">
			//This method is CPU-bound.
			void DoWork();	

			//You would call using Task.Run:
			await Task.Run(() => DoWork());		
		</pre>
		<li>i/o-bound: await 避免主线程阻塞等待</li>
	</ol>

	<hr />
	<h1>dotnet core 生成 windows service</h1>
	适用于各种开机自启动服务进程
	<ol>
		<li>dotnet publish -c Release</li>
		<li>sc.exe create servicecenter binPath=C:\servicecenter.exe</li>
		<li>sc.exe start servicecenter</li>
		<li>sc.exe stop servicecenter</li>
		<li>sc.exe delete servicecenter</li>
		<li>sc.exe query servicecenter</li>
	</ol>
	<hr />
	<h1>重构服务器</h1>
	主体思想：c++切换为c#；lib切换为进程；服务为所有区共享。
	<ol>
		<li>中心服，负责消息转发</li>
		<li>网关服，负责客户端socket连接</li>
		<li>聊天服</li>
		<li>排行榜</li>
		<li>日志服</li>
		<li>邮件服</li>
		<li>场景服</li>
		<li>好友服</li>
		<li>商店服</li>
		<li>活动服</li>
		<li>结婚服</li>
		<li>组队服</li>
		<li>数据服</li>
	</ol>
	<hr />
	<h1>IIS下部署https</h1>
	<ol>
		<li>https: Hyper Text Transfer Protocol over SecureSocket Layer</li>
		<li>TLS(Transport Layer Security)/SSL(Secure Socket Layer)</li>
		<li>申请SSL证书，有免费和收费的两种，小公司用免费的即可</li>
		本次在<a href="https://www.ucloud.cn/">uclound</a>申请免费ssl
		<li>在<a href="https://myssl.com/cert_convert.html">转换页面</a>，导入公钥、私钥，格式从PEM转换为PKCS12，得到pfx后缀文件</li>
		<li>web服务器，复制pfx文件到本地，命令行输入mmc，File菜单Add or Remove Snap-ins，左侧选择Certificates，点击Add，Computer account</li>
		<li>左侧树形菜单，Certificates->Personal->Certificates，右键菜单 All Tasks->Import，选择pfx文件，password未填写，一路默认</li>
		<li>IIS Manager -> 右键 Site -> Edit Bindings -> Add -> Type 选择https -> ssl certificates 选择上面安装的证书</li>
		<li>记得开放https的端口，默认443，如同http的默认端口80</li>
		<li>打开浏览器测试</li>
	</ol>

	<hr />
	<h1>加密算法-对称加密</h1>
	加密和解密，都是用的同一个密钥。
	<ol>
		<li>DES</li>
		Data Encryption Standard
		<li>AES</li>
		<li>IDEA</li>
	</ol>

	<hr />
	<h1>加密算法-非对称加密</h1>
	加密和解密，需要用不同的密钥：公钥和私钥，二把钥匙都可以用于加密或者解密。
	<ol>
		<li>RSA</li>
		<li>DSA</li>
	</ol>

	<hr />
	<h1>硬盘性能量化-Windows System Assessment Tool</h1>
	winsat disk -drive d

	<hr />
	<h1>apk修改packagename</h1>
	<ol>
		<li>apktool</li>
		https://ibotpeaches.github.io/Apktool/install/

		<li>解apk</li>
		java -jar apktool.jar d 仙境苍穹.apk -o huawei

		<li>打apk</li>
		java -jar apktool.jar b huawei -o ./仙境苍穹huawei.apk

		<li>生成key</li>
		uc huawei oppo vivo 可以采用以下key
		./keytool.exe -genkey
		密码 euler2019
		名字 euler

		应用宝需要以下key
		./keytool.exe -genkey -alias myaliassha1 -sigalg SHA1withRSA -keyalg RSA


		<li>查看alias</li>
		./keytool.exe -keystore euler.keystore -list -v

		<li>签名</li>
		uc huawei oppo vivo
		.\jarsigner.exe -verbose -keystore euler.keystore -signedjar 仙境苍穹huawei_s.apk 仙境苍穹huawei.apk mykey

		应用宝
		.\jarsigner.exe -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore euler2.keystore -storepass euler2019
		tencent.apk myaliassha1
	</ol>
	<hr />
	<h1>部署DB服务器</h1>
	<ol>
		<li>复制并安装SQLServer2016</li>
		en_sql_server_2016_enterprise_with_service_pack_1_x64_dvd_9542382.iso
		设置sa密码Euler2019
		修改端口为38065
		red gate sql compare 同步数据库
		web 全局配置
		collation Chinese_PRC_CI_AS

		gd 策划配置

		ds 玩家数据

		dslog 玩家日志

		gm 运维后台


		<li>TotalCommander</li>
		<li>BeyondCompare</li>
		<li>Server Manager - Add roles and features - Web Server(IIS)</li>
		<li>Install the .NET Core Hosting Bundle</li>
		dotnet-hosting-2.2.6-win.exe，安装成功之后，IIS的modules里，可以看到AspNetCoreModule
		以及AspNetCoreModuleV2
		<li>TortoiseSVN</li>
		release
		release
		https://59.111.63.232/svn/deerdev/Web/bin
		拉取游戏的web服务
		<li>挨个配置Web服务，测试URL，如有报错，查看logs是否有日志输出</li>
		monitor读取本机进程需要权限设置,IIS - Application Pools - Identity设置为LocalSystem

	</ol>
	<hr />
	<h1>svn提交注释字数限制</h1>
	<pre class="prettyprint">
@echo off  
::      
:: Stops commits that have empty log messages.  
::  
  
@echo off  
  
setlocal  
  
rem Subversion sends through the path to the repository and transaction id  
set REPOS=%1  
set TXN=%2  
  
rem check for an empty log message, at least 6 characters
svnlook log %REPOS% -t %TXN% | findstr "......" > nul
if %errorlevel% gtr 0  (goto err) else exit 0  
  
:err  
echo. 1>&2  
echo 抱歉,由于您没有正确填写Log或者Log字数过少,系统拒绝提交！ 1>&2   
exit 1	
</pre>


	<hr />
	<h1>创建角色的人声</h1>
	<pre class="prettyprint linenums">
function UIActor:ShowModel(actorData)
	local vocation = (UIActor.createActor.curVocation - 1) * 2 + UIActor.createActor.curSex
	local vocationScheme = Schemes.SkillVocation.Get(vocation)
	local soundID = vocationScheme.Talk
	local soundPath = Schemes.Sound.Get(soundID)
	local soundPrefab = HotResManager.ReadSound(soundPath.File)
	HelperL.AddAudioClip(UIActor.curModelInfo["model"], soundPrefab)
end

	</pre>

	<hr />
	<h1>任务栏</h1>
	<pre class="prettyprint linenums">
--UITaskShowItem.lua
o.OnClickContentObj = function ( go1 )
	local clientStatus = self.taskItem.GetClientStatus and self.taskItem:GetClientStatus() or ECTaskStatus.Null
	if clientStatus == ECTaskStatus.CanComplete then
		self.taskItem:WantToTurnInTask()
	end
end

--Task.lua
WantToTurnInTask = function ( self )
		CommonWantToTurnIn(self)
end

local function CommonWantToTurnIn( task )
		local _,_,giveNPC  = CommonGetTaskNPC(task)
		if giveNPC ~= 0 then
			EntityModule.hero.navigationLG:NavigateToNPC(giveNPC)
		else
			EntityModule.hero:SetWorldDestination(
					tagMapID,
					HelperL.PBString2Vector3(task.GivePoint),
					false)
		end
end

--- 寻路到npc的位置
function navigationLG:NavigateToNPC( npcID, onHeroReached, isNext, isFollow )
	local npcScheme = Schemes.SceneNpc.Get(npcID)
	local targetMapID = npcScheme.MapID
	local tarPos = Vector3(npcScheme.PosX, npcScheme.PosY, npcScheme.PosZ)
	local naviInfo = NavigationInfo.New('npc',
		tarPos,
		targetMapID,
		searchNPC,
		npcID)
	self:SetFinalPos(naviInfo)
	self:StartNavigation()
end

function navigationLG:StartNavigation()
	HeroController:MoveToPos( navigationInfo.point, navigationInfo.potType == 'npc' and 3 or 0.1, false)
end

-- 要求寻路
function HeroController:MoveToPos(targetPos, distance, clearCmd)
	local moveCmdInfo = { cmdType = CMD_TYPE_MOVE, begin = false, target = targetPos, stopDistance = distance }
	self:AddCmd(moveCmdInfo)
end

-- 每帧调用函数
function Main_Update()
	HeroController:Update()
end

-- 检查命令列表
function HeroController:Update()
	-- 正在执行中检测是否结束
	if self.cmdList[1].begin then
		if CheckCmdEnd(self.cmdList[1]) then
			OnCmdEnd(self.cmdList[1])
			table.remove(self.cmdList, 1)
		end
	end
end

-- 检查命令是否结束
local function CheckCmdEnd(cmdInfo)
	if cmdInfo.cmdType == CMD_TYPE_MOVE then
		if hero.navComp.HasDestination then
			return false
		end
		if EntityModule.hero.navigationLG.isInNavigation then
			EntityModule.hero.navigationLG.AfterHeroStop()
		end
		return true
	end
	return true
end

function navigationLG.AfterHeroStop(  )
		local navigationInfo = navigationLG.finalPos
		navigationLG.ReachPosition(navigationInfo, true)
end

function navigationLG.ReachPosition( naviInfo , isFinal)
	if naviInfo.potType == 'npc' then
		naviInfo.afterStopFunc(naviInfo.npcID)
	end
end

local searchNPC = function ( id )
	if NPCManager.npcs[id] then
		local npc= NPCManager.npcs[id]
		npc.npcComp:TriggerEvent(true)
	end
end

function TaskNPC:TriggerEvent()
	if GuideManager.isRunning then return end--引导过程禁止任务对话
	if NPCFunManager.funHandle[self.npcScheme.ID] ~= nil then
		if chuSocietyEscortItem and (self.npcScheme.ID == chuSocietyEscortItem.FinishNpcID or self.npcScheme.ID == hanSocietyEscortItem.FinishNpcID) then  
			NPCFunManager.funHandle[self.npcScheme.ID](self.npcScheme.ID,self)		
		else
			NPCFunManager.funHandle[self.npcScheme.ID](self.npcScheme.ID,self)
			return
		end
	end
	if CheckNPCHeroDistance(self.npcScheme.ID) then
		NPCManager.lastTrigNpcID = self.npcScheme.ID
		if self.dataItem and
			self.dataItem.taskScheme.Type == TaskType.TaskType_TimeTalk and
			self.dataItem.taskScheme.Parameter3 == 1 and
			self.dataItem:GetClientStatus() == ECTaskStatus.Doing then
				EntityModule.ForceSyn()
				self:AfterTimeProgress()
				--[[
				-- 读条机制正规化，这里稳定后可删
				UIManager.AddATimeProgress(self.dataItem.taskScheme.Parameter4,
											self.dataItem.taskScheme.Parameter1,
											function()
												self:AfterTimeProgress()
											end)
				]]
		else
			local heroTaskLC = EntityModule.hero.heroTaskLC
			local curFocusTask = heroTaskLC.curFocusTask
			if curFocusTask then
				local key = curFocusTask.taskID * 256 + curFocusTask.branchID
				local status = curFocusTask:GetClientStatus()
				if heroTaskLC.idToItem[key] and status ~= ECTaskStatus.Completed then
					local acceptNPC, doNPC, turnInNPC = CommonGetTaskNPC(curFocusTask)
					if acceptNPC == self.npcScheme.ID or
						doNPC == self.npcScheme.ID or 
						turnInNPC == self.npcScheme.ID then
						self.dataItem = curFocusTask
						NPCTaskTalkUI:Init(self,self.dataItem)
						return
					end
				end
			end
			self:InitStatus()
			if self.taskQueue then
				if self.taskQueue:Count() > 1 then
					NPCMutiTasksUI:Init(self)
				elseif self.taskQueue:Count() == 1 then

					local task =self.taskQueue:peekFirst()
					NPCTaskTalkUI:Init(self,task)
				end
			else
				NPCTaskTalkUI:Init(self)
			end
		end
	end
end
</pre>

	<hr />
	<h1>引导</h1>
	<pre class="prettyprint">
GuideManager.EventType =
{
	UpdateEvent             =           1,              --升级事件
	EnterSceneEvent         =           2,              --进入场景事件
	ReceiveTaskEvent        =           3,              --接受任务事件
	FinishTaskEvent         =           4,              --完成任务事件
	KillMonsterEvent        =           5,              --击杀怪物事件
	OpenWindowEvent         =           6,              --打开窗口事件
	FunctionOpenEvent       =           7,              --功能开启事件
	NextEvent               =           8,              --引导触发
	CampOpen                =           11,              --阵营选择事件
	CameraShowOver          =           12,              --镜头播放完事件
}

function GuideManager.GuideEventStart(n)
	curEventID= EntityModule.hero.logicLC:Get(LOGIC_DATA.DATA_GUIDELOG_EVENTID)   --引导事件ID
	curEventID = curEventID + 1
	eventItem = Schemes.GuideEvent.Get(curEventID)
	curGuideID=eventItem.GuideID
	if eventItem.Event == self.EventType.UpdateEvent then
		self:CheckUpdateEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.EnterSceneEvent and n == 2 then
		self:CheckEnterSceneEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.ReceiveTaskEvent and n ~= 5 then
		self:CheckReceiveTaskEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.FinishTaskEvent and n ~= 5 and n ~= 7 and n~=3 then
		self:CheckFinishTaskEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.KillMonsterEvent then
		self:CheckKillMonsterEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.OpenWindowEvent and n~=2 then
		self:CheckOpenWindowEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.FunctionOpenEvent and n == 7 then
		self:CheckFunctionOpenEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.CampOpen and n == 11  then
		self:CheckSelectCampEvent(eventItem,curEventID)
	elseif eventItem.Event == self.EventType.CameraShowOver and n == 12 then
		self.NavigationPause()
		self:CheckCameraShowOverEvent(eventItem,curEventID)
	end
end

--检测升级事件
function GuideManager:CheckUpdateEvent(eventItem,eventID)
	local playerLV = EntityModule.hero.propertyLC:GetProperty(CREATURE_FIELD.CREATURE_FIELD_LEVEL)
	if playerLV >= eventItem.Parameter and (playerLV >= eventItem.LevelMin and playerLV <= eventItem.LevelMax) then
		self.TriggerEvent(eventItem.GuideID,eventID)
	end
end

--检测接受任务事件
function GuideManager:CheckReceiveTaskEvent(eventItem,eventID)
	local taskList = EntityModule.hero.heroTaskLC.taskStatusList[TASK_STATUS.TASK_STATUS_ACCEPTED]
	local isFind = false
	for _,v in ipairs(taskList) do
		local key = v
		local tID = math.floor(key / 256)
		if tID == eventItem.Parameter then isFind = true end
	end
	local playerLV = EntityModule.hero.propertyLC:GetProperty(CREATURE_FIELD.CREATURE_FIELD_LEVEL)
	if isFind and (playerLV >= eventItem.LevelMin and playerLV <= eventItem.LevelMax) then
		self.TriggerEvent(eventItem.GuideID,eventID)
	end
end

--检测打开窗口事件
function GuideManager:CheckOpenWindowEvent(eventItem,eventID)
	local playerLV = EntityModule.hero.propertyLC:GetProperty(CREATURE_FIELD.CREATURE_FIELD_LEVEL)
	if UIManager.curWindowID == eventItem.Parameter and (playerLV >= eventItem.LevelMin and playerLV <= eventItem.LevelMax) then
		self.TriggerEvent(eventItem.GuideID,eventID)
	end
end

--检测功能开启事件
function GuideManager:CheckFunctionOpenEvent(eventItem,eventID)
	local playerLV = EntityModule.hero.propertyLC:GetProperty(CREATURE_FIELD.CREATURE_FIELD_LEVEL)
	if FunctionOpenManager.serverRecordID == eventItem.Parameter and (playerLV >= eventItem.LevelMin and playerLV <= eventItem.LevelMax) then
		self.TriggerEvent(eventItem.GuideID,eventID)
	end
end

function GuideManager.CheckGuideEvent(n)
	self.GuideEventStart(n)
end


function MainLandUI.Guide(n, param1, param2, param3 )
	GuideManager.CheckGuideEvent(n)
	FunctionOpenManager:CheckFunctionOpenEvent(n)
end

function MainLandUI.Awake()
	EventManager.Subscribe(EventID.CheckGuideEvent, MainLandUI.Guide)
end

EventManager.Fire(EventID.CheckGuideEvent,5)

</pre>
	<hr />
	<h1>NPC语音</h1>
	<pre class="prettyprint">
NPCTaskTalkUI.Init = function (self, caller, task )
	local npc = NPCManager.npcs[caller.npcScheme.ID]
	local npcScheme = caller.npcScheme
	-- 默认对话
	local param = ProcessDialog(npcScheme.Talk)
	local soundPath, volume = GetSoundPath(true, param.soundNum)
	NPCTaskTalkUI.DefaultTalk(param.isNpc, soundPath, volume, param.str)
end

local function ProcessDialog( str )
	return  {isNpc = isNpc, str = tempStr, soundNum = soundNum ,cameraID = cameraID}
end

NPCTaskTalkUI.DefaultTalk = function (isNpc, fileStr, volume, str )
	NPCTaskTalkUI.HeroHead(isNpc, fileStr, volume, str)
end

function NPCTaskTalkUI.HeroHead( isNpc, fileStr, volume, str)
	local function GetNPCSoundElement( ... )
		local o = NGUITools.AddChild(UIManager.soundElementPivot)
		o.name = 'npcsound'
		return o:AddComponent(System.Type.GetType('UnityEngine.AudioSource, UnityEngine'))
	end
	NPCTaskTalkUI.audioComp = NPCTaskTalkUI.audioComp or GetNPCSoundElement()
	local clip = HotResManager.ReadSound(fileStr)
	NPCTaskTalkUI.audioComp.clip = clip
	NPCTaskTalkUI.audioComp.volume = volume
	NPCTaskTalkUI.audioComp:Play()
end
</pre>

	<hr />
	<h1>概率</h1>
	<hr />
	<h2>均匀概率</h2>
	<hr />
	<h2>正态概率</h2>

	<hr />
	<h1>主线任务</h1>
	<pre class="prettyprint">
bool CTaskPart::Create(IEntity* pMaster, LPCSTR pContext, int nLen)
{
	IEventEngine* pEventEngine = Global->GetEventEngine();
	pEventEngine->Subscibe((IEventExecuteSink*)this, EVENT_PLAYER_LOGIN, SOURCE_TYPE_PLAYER, (DWORD)m_pMaster, "CTaskPart::Create");
	pEventEngine->Subscibe((IEventExecuteSink*)this, EVENT_PLAYER_CREATECLIENT, SOURCE_TYPE_PLAYER, (DWORD)m_pMaster, "CTaskPart::Create");
	pEventEngine->Subscibe((IEventExecuteSink*)this, EVENT_PLAYER_LOGOUT, SOURCE_TYPE_PLAYER, (DWORD)m_pMaster, "CTaskPart::Create");
	return true;
}

void CTaskPart::OnExecute(WORD wEventID, BYTE bSrcType, DWORD dwSrcID, LPCSTR pszContext, int nLen)
{
	if(wEventID == EVENT_PLAYER_LOGIN && bSrcType == SOURCE_TYPE_PLAYER)
	{
		PlayerTaskLogin();
	}
	if (wEventID == EVENT_PLAYER_CREATECLIENT && bSrcType == SOURCE_TYPE_PLAYER)
	{
		SendTaskData();
	}
	if(wEventID == EVENT_PLAYER_LOGOUT && bSrcType == SOURCE_TYPE_PLAYER)
	{
		PlayerTaskLogout();
	}
}

void CTaskPart::PlayerTaskLogin()
{
	Json::Value root;
	TaskItemMap::iterator it = m_mapTaskItem.begin();
	for (; it != m_mapTaskItem.end(); ++it)
	{
		STaskItem &task = it->second;
		Json::Value info;
		info["BranchID"] = (int)task.byBranchID;
		info["TaskID"] = (int)task.dwTaskID;
		info["Step"] = (int)task.byStep;
		info["Round"] = (int)task.wRound;
		root.append(info);
	}
	Json::FastWriter writer;
	CLuaParam input[2];
	input[0] = m_pMaster->GetActorID();
	input[1] = writer.write(root).c_str();
	if (!GetLuaModule()->RunFunction("PlayerTaskLogin", input, 2, NULL, 0))
	{
		_error("CTaskPart::PlayerTaskLogin run lua function false");
	}
}

function PlayerTaskLogin(actorID, taskJson)
	InitActorTask(actorID)
	InitBranchTask(actorID)
	local TTaskJson = json.decode(taskJson)
	local taskNum = #TTaskJson
	local serverTime = Lua_ServerTime()
	for i = 1, taskNum do
		local info = TTaskJson[i]
		local branchID = info["BranchID"]
		local taskID = info["TaskID"]
		local step = info["Step"]
		local count = info["Round"]
		local schemeData = Schemes.Task.Get2( taskID, step)
		local task = TaskFactory(actorID, branchID, taskID, step, schemeData, count )
		local status = Lua_GetTaskStatus(actorID, branchID, taskID)
		if status == TASK_STATUS_ACCEPTED then
			AddActorTask(task)
		end
		if task.BranchID ~= 0 then
			AddBranchTask(task)
		end
	end
	GetPlayerDailyTasks(actorID)
end

function InitActorTask(actorID)
	for taskType = (TaskType_Null + 1), (TaskType_MaxID - 1) do
		local key = MAKELISTENERKEY(actorID, taskType)
		TTaskList[key] = nil
	end
end

function MAKELISTENERKEY(actorID, taskType)
	return actorID * 256 + taskType
end

function InitBranchTask(actorID)
	TActorBranchTaskList[actorID] = nil
end

//DgameEnum.h
enum TaskType =
{
	TaskType_Null = 0,
	TaskType_KillTargetMonster = 1,
	TaskType_DramaEctype = 2,
	TaskType_DailyEctype = 3,
	TaskType_JoinActivity = 4,
	TaskType_KillLevelMonster = 5,
	TaskType_Talk = 6,
	TaskType_TimeTalk = 7,
	TaskType_TimePass = 8,
	TaskType_ActorLevel = 9,
	TaskType_FriendShip = 10,
	TaskType_KillPlayer = 11,
	TaskType_Escort = 12,
	TaskType_TalkEctype = 13,
	TaskType_CollectGood = 14,
	TaskType_TalkThenTransmit = 15,
	TaskType_UpGrade = 16,
	TaskType_DoDailyTask = 17,
	TaskType_OperateCollectGood = 18,
	TaskType_EveryDayUpgrade = 19,
	TaskType_EnterScene = 20,
	TaskType_NewbieTarget = 21,
	TaskType_LoginDay = 22,
	TaskType_BuyRechargeCard = 23,
	TaskType_MaxID = 24,
};

function GetPlayerDailyTasks( actorID )
	local actorGroupTaskList = GetActorGroupTaskList(actorID)
	local vipLevel = GetPlayerNumProp(actorID, PLAYER_FIELD_VIPLEVEL)
	for groupID, v in pairs(BranchGroup) do
		local curGroupTask = actorGroupTaskList.TaskIDList[groupID]
		-- 如果没有接受该任务组的任务
		if not curGroupTask then
			local groupTaskScheme = GetGroupTaskPlayerCanAccept(actorID, groupID)
			if groupTaskScheme then
				if groupTaskScheme.Refresh == 0 then
					if groupTaskScheme.VIPLevel == 0 or groupTaskScheme.VIPLevel > vipLevel  then
						local newTaskID = RandomGetBranchTaskID(actorID, groupTaskScheme)
						NewBranchTask(actorID, newTaskID)
					else
						local newTaskID = RandomGetVIPBranchTaskID(actorID, groupTaskScheme)
						NewBranchTask(actorID, newTaskID )
					end
				else
					if groupTaskScheme.VIPLevel == 0 or groupTaskScheme.VIPLevel > vipLevel then
						local newTaskID = GetBranchTaskID(actorID, groupTaskScheme, 1)
						NewBranchTask(actorID, newTaskID)
					else
						local newTaskID = GetBranchVIPTaskID(actorID, groupTaskScheme, 1)
						NewBranchTask(actorID, newTaskID)
					end
				end
			end
		end
	end
end

function GetActorGroupTaskList(actorID)
	local branchTaskList = TActorBranchTaskList[actorID]
	if branchTaskList == nil then
		branchTaskList = BranchTaskList:new()
		branchTaskList.ActorID = actorID
		TActorBranchTaskList[actorID] = branchTaskList
	end
	return branchTaskList
end

--- 对任务分组处理
BranchGroup = {}
local function GroupBranchTask()
	for _, v in pairs( Schemes.TaskBranch.items ) do
		if v and v.GroupID then
			local groupID = v.GroupID
			BranchGroup[groupID] = BranchGroup[groupID] or {}
			table.insert(BranchGroup[groupID], v)
		end
	end
end

--- 获取该任务组中玩家可以接受的任务
function GetGroupTaskPlayerCanAccept ( actorID, groupID )
	local groupTaskList = BranchGroup[groupID]
	local actorLevel = Lua_GetPlayerNumProp(actorID, CREATURE_FIELD_LEVEL)
	for k,v in pairs( groupTaskList) do
		if CanAcceptBranchTask(actorLevel, v.MinLevel, v.MaxLevel) then
			return v
		end
	end
	return nil
end

local function CanAcceptBranchTask( actorLevel, minLevel, maxLevel )
	if actorLevel >= minLevel and actorLevel <= maxLevel then
		return true
	end
	return false
end

function RandomGetBranchTaskID(actorID ,curTaskBranchScheme, taskQuality)
	local taskIDs = RandomGetBranchTask(actorID, curTaskBranchScheme, taskQuality)
	local countryID = GetPlayerNumProp(actorID, PLAYER_FIELD_COUNTRY)
	if #taskIDs == 1 then
		return taskIDs[1]
	end
	return taskIDs[countryID + 1]
end

function RandomGetBranchTask(actorID, taskBranchScheme, taskQuality)
	local beginIndex = 1
	if taskBranchScheme.Refresh == 2 then
		beginIndex = taskQuality
	end
	local randMax = 0
	for index = beginIndex, 5 do
		local tmp = weightStr[index]
		local tmpWeight = taskBranchScheme[tmp]
		randMax = randMax + tmpWeight
	end
	local rdm = Lua_GetRandomInt(0, randMax - 1)
	local taskWeightSum = 0
	for index = beginIndex, 5 do
		local tmp = weightStr[index]
		local tmpWeight = taskBranchScheme[tmp]
		taskWeightSum = taskWeightSum + tmpWeight
		if rdm < taskWeightSum then
			return taskBranchScheme[taskStr[index]]
		end
	end
end

local weightStr = { 'Weight1', 'Weight2', 'Weight3', 'Weight4', 'Weight5', }
local taskStr = { 'Task1', 'Task2', 'Task3', 'Task4', 'Task5', }

function RandomGetVIPBranchTaskID(actorID, taskBranchScheme, taskQuality)
	local taskIDs = RandomGetVIPBranchTask(taskBranchScheme, taskQuality)
	local countryID = GetPlayerNumProp(actorID, PLAYER_FIELD_COUNTRY)
	if #taskIDs == 1 then
		return taskIDs[1]
	end
	return taskIDs[countryID + 1]
end

function RandomGetVIPBranchTask(taskBranchScheme, taskQuality)
	local beginIndex = 1
	if taskBranchScheme.Refresh == 2 then
		beginIndex = taskQuality - 2
		if beginIndex < 1 then
			beginIndex = 1
		end
	end
	local randMax = 0
	for index = beginIndex, 3 do
		local tmp = vipWeightStr[index]
		local tmpWeight = taskBranchScheme[tmp]
		randMax = randMax + tmpWeight
	end
	local rdm = Lua_GetRandomInt(0, randMax - 1)
	local taskWeightSum = 0
	for index = beginIndex, 3 do
		local tmp = vipWeightStr[index]
		local tmpWeight = taskBranchScheme[tmp]
		taskWeightSum = taskWeightSum + tmpWeight
		if rdm < taskWeightSum then
			return taskBranchScheme[vipTaskStr[index]]
		end
	end
	return nil
end

local vipWeightStr = { 'VIPWeight1', 'VIPWeight2', 'VIPWeight3', }
local vipTaskStr = { 'VIPTaskID1', 'VIPTaskID2', 'VIPTaskID3', }

function GetBranchTaskID(actorID, taskBranchScheme, index )
	local taskIDs = taskBranchScheme['Task'..index]
	local countryID = GetPlayerNumProp(actorID, PLAYER_FIELD_COUNTRY)
	if #taskIDs == 1 then
		return taskIDs[1]
	end
	return taskIDs[countryID + 1]
end

function GetBranchVIPTaskID( actorID, taskBranchScheme, index )
	local taskIDs = taskBranchScheme['VIPTaskID'..index]
	local countryID = GetPlayerNumProp(actorID, PLAYER_FIELD_COUNTRY)
	if #taskIDs == 1 then
		return taskIDs[1]
	end
	return taskIDs[countryID + 1]
end


function NewBranchTask(actorID, newTaskID, newRound, newStep, notSync )
	newStep = newStep or 1
	local taskScheme = Schemes.Task.Get2(newTaskID, newStep)
	local newTask = TaskFactory(actorID, 1, newTaskID, newStep, taskScheme, newRound )
	local addResult = newTask:AddBranch(notSync)
	AddActorTask(newTask)
	AddBranchTask(newTask)
	return newTask
end

</pre>
	<hr />
	<h2>第一个主线任务</h2>
	<pre class="prettyprint">
function EntityModule.Handle(action, data)
	if action == EntityMessage_pb.MSG_ENTITY_SYNCTASKITEM then
			local m = EntityMessage_pb.SC_Entity_SyncTaskItem()
			m:ParseFromString(data)
			EntityModule.SC_Entity_SyncTaskItem(m)
	end
end

function EntityModule.SC_Entity_SyncTaskItem(m)
	EntityModule.hero.heroTaskLC.Update(m)
end

function o.Update( message )
	--找下一个主线任务的ID
	local taskSerial = EntityModule.hero.logicLC:Get( LOGIC_DATA.DATA_TRUNK_TASK_CUR_SERIAL)
	local nextTaskID = 0
	if taskSerial == 0 then
		nextTaskID = 1
	end
	local taskScheme = Schemes.Task.Get(nextTaskID, 1)
	o.UpdateData({BranchID = 0, TaskID = nextTaskID, Step = 1,AcceptTime = 0,Status = TASK_STATUS.TASK_STATUS_NULL,
	Round = 0,Score = 0,Change = 1})
end

function o.UpdateData(value  )
	local data = NewTaskItem()
	data.branchID = value.BranchID
	data.taskID = value.TaskID
	data.step = value.Step or 1
	data.acceptTime = value.AcceptTime or 0
	data.status = value.Status or TASK_STATUS.TASK_STATUS_NULL
	data.round = value.Round or 0
	data.score = value.Score or 0
	data.change = value.Change or 1

	local taskScheme = Schemes.Task.Get(data.taskID, data.step)
	data.taskScheme = taskScheme
	o.UpdateTask(data)
end

function o.UpdateTask( taskItem )
	local key  = taskItem.taskID * 256 + taskItem.branchID
		
	--加入新的数据
	o.idToItem[key] = TaskFactory(taskItem.taskScheme.Type,
		taskItem.branchID,
		taskItem.taskID,
		taskItem.step,
		taskItem.acceptTime,
		taskItem.status,
		taskItem.round,
		taskItem.score,
		taskItem.taskScheme)
end

--玩家模型加载回调
function EntityModule.OnHeroModelLoaded(obj, uidParam, fileName)
	local o = EntityModule.entities[tostring(uidParam)]
	--处理新建角色的第一个主线任务
	if o.heroTaskLC then
		local task = o.heroTaskLC.idToItem[256]
		if task and task:GetClientStatus() == ECTaskStatus.CanAccept then
			task:WantToAccept()
		end
	end
end

local TalkTask = {
	GetClientStatus = function (self, ignoreBranchType)
		return CommonGetClientStatus(self, ignoreBranchType)
	end,
	CanAccept = function (self, checkDistance)
		return CommonCanAcceptTask(self, checkDistance)
	end,
}

local function CommonGetClientStatus( task, ignoreBranchType)
	local self = task
	if self.status == TASK_STATUS.TASK_STATUS_COMPLETED then 
		return ECTaskStatus.Completed
	end
	if self.branchID == 1 then
		local branchScheme = GetThisTaskBranchScheme(task)
		if not branchScheme or self.round == branchScheme.GroupCount then
			return ECTaskStatus.Completed 
		end
	end
	if self.status == TASK_STATUS.TASK_STATUS_ACCEPTED and self:CanComplete() then
		return ECTaskStatus.CanComplete 
	end
	if self.status == TASK_STATUS.TASK_STATUS_ACCEPTED then
		return ECTaskStatus.Doing 
	end
	if self.status == TASK_STATUS.TASK_STATUS_NULL or
		self.status == TASK_STATUS.TASK_STATUS_BRANCH or
		self.status == TASK_STATUS.TASK_STATUS_ROUND then
		local canAccept, resultCode = self:CanAccept()
		if canAccept then
			return ECTaskStatus.CanAccept
		end
	end
	return ECTaskStatus.Null
end

local function CommonWantToAccept( task )
	EntityModule.hero.heroTaskLC.SetFocusTask(task)
	local acceptNPC,_,_ = CommonGetTaskNPC(task)
	--有npc则去找npc接任务
	if acceptNPC ~= 0 then
		EntityModule.hero.navigationLG:NavigateToNPC(acceptNPC)
	else
	--没有npc，直接去服务器请求接任务
		EntityModule.hero.heroTaskLC.SendLuaAcceptTask(task.branchID,task.taskID, task.step)
	end
end

</pre>
	<hr />
	<h1>角色出生副本</h1>
	<pre class="prettyprint linenums">
bool CTerminalModule::Create()
{
	RegisterMessage(MSG_MODULEID_LOGIN, this);
	return true;
}
void CTerminalModule::DispatchMessage(LPCSTR lpBuf, int nLen)
{
	static MsgHead head;
	if (!head.ParseFromArray(lpBuf, nLen))
	{
		return;
	}
	WORD wModuleID = head.wkeymodule();
	IMessageHandler* pMessageHandler = m_arrLpMessageHandler[wModuleID];
	if (wModuleID == MSG_MODULEID_LOGIN)
	{
		pMessageHandler->OnMessage(NULL, head);
	}
}
void CTerminalModule::OnMessage(IPlayer* pPlayer, const MsgHead& head)
{
	switch (head.wkeyaction())
	{
		case MSG_LOGIN_SELETEACTOR:
			OnUserSelectActor(head);
			break;
	}
}
void CTerminalModule::OnUserSelectActor(const MsgHead& head)
{
	AS_Login_SeleteActor message;
	if (!message.ParseFromString(head.body()))
	{
		_fileline();
		return;
	}
	LPCSTR szActorName = message.actorname().c_str();

	auto pTerminalTunnel = new CTerminalTunnel();
	if (!pTerminalTunnel->Create(agentid, message.clientid(), message.actorid()))
	{
		_warn("角色-%s登录失败", szActorName);
		pTerminalTunnel->Release();
		pTerminalTunnel = NULL;
		return;
	}
}
bool CTerminalTunnel::Create(DWORD dwAgentID, DWORD dwClientID, DWORD dwActorID)
{
	DBINPUT_LOAD_ACTOR_COMMAND dbInputCommand;
	dbInputCommand.dwActorID = m_dwActorID;
	if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_COMMAND, (LPCSTR)&dbInputCommand, sizeof(dbInputCommand)))
	{
		_error("CTerminalStateLogin::OnEnter 请求角色常规数据失败，dwActorID=%d", m_dwActorID);
		return false;
	}
	DBINPUT_LOAD_ACTOR_GOODS dbInputGoods;	
	dbInputGoods.dwActorID = m_dwActorID;
	if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_GOODS, (LPCSTR)&dbInputGoods, sizeof(dbInputGoods)))
	{
		_error("CTerminalStateLogin::OnEnter 请求角色物品数据失败，dwActorID=%d", m_dwActorID);
		return false;
	}
	DBINPUT_LOAD_ACTOR_TASK dbInputTask;	
	dbInputTask.dwActorID = m_dwActorID;
	if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_TASK, (LPCSTR)&dbInputTask, sizeof(dbInputTask)))
	{
		_error("CTerminalStateLogin::OnEnter 请求角色任务数据失败，dwActorID=%d", m_dwActorID);
		return false;
	}
}
void CTerminalTunnel::OnReturn(DWORD dwSpID, int nRetCode, LPCSTR pOutData, int nOutLen)
{
	switch (dwSpID)
	{
	case SPID_LOAD_ACTOR_COMMAND:
		{
			m_lpCommandData = new char[nOutLen];
			memcpy(m_lpCommandData, pOutData, nOutLen);
			m_nCommandLen = nOutLen;
		}
		break;
	case SPID_LOAD_ACTOR_GOODS:
		{
			m_lpGoodsData = new char[nOutLen];
			memcpy(m_lpGoodsData, pOutData, nOutLen);
			m_nGoodsLen = nOutLen;
		}
		break;
	case SPID_LOAD_ACTOR_TASK:
		{
			m_lpTaskData = new char[nOutLen];
			memcpy(m_lpTaskData, pOutData, nOutLen);
			m_nTaskLen = nOutLen;
		}
		break;
	default:
		_error("角色在登录状态收到错误的数据库返回,dwSpID=%d", dwSpID);
		break;
	}
	if (m_lpCommandData == NULL || m_nCommandLen == 0 
		|| m_lpGoodsData == NULL || m_nGoodsLen == 0 
		|| m_lpTaskData == NULL || m_nTaskLen == 0)
	{
		return;
	}

	SBuildPlayerDB sBuildPlayerDB;
	sBuildPlayerDB.lpCommandData = m_lpCommandData;
	sBuildPlayerDB.nCommandLen = m_nCommandLen;
	sBuildPlayerDB.lpGoodsData = m_lpGoodsData;
	sBuildPlayerDB.nGoodsLen = m_nGoodsLen;
	sBuildPlayerDB.lpTaskData = m_lpTaskData;
	sBuildPlayerDB.nTaskLen = m_nTaskLen;
	pPlayer = (IPlayer*)GetEntityModule()->BuildEntityDB(ENTITY_CLASS_PLAYER, (LPCSTR)&sBuildPlayerDB, sizeof(sBuildPlayerDB));
	if (pPlayer == NULL)
	{
		_error("CTerminalStateLogin::OnReturn 创建角色[%d]失败", m_dwActorID);
		Kickout(RESULT_COMMON_ERROR);
		return;
	}
	BindPlayer(pPlayer, false);
}
void CTerminalTunnel::BindPlayer(IPlayer* pPlayer, bool skipInit)
{
	IEventEngine* pEventEngine = Global->GetEventEngine();
	if (pEventEngine != NULL)
	{
		pEventEngine->FireExecute(EVENT_PLAYER_LOGIN, SOURCE_TYPE_PLAYER, (DWORD)m_pPlayer, NULL, 0);
	}
}
bool CLuaGameEvent::Create()
{
	IEventEngine* pEventEngine = Global->GetEventEngine();
	pEventEngine->Subscibe(this, EVENT_PLAYER_LOGIN, SOURCE_TYPE_PLAYER, 0, "CLuaGameEvent::Create");
	return true;
}
void CLuaGameEvent::OnExecute(WORD wEventID, BYTE bSrcType, DWORD dwSrcID, LPCSTR pszContext, int nLen)
{
	if (bSrcType == SOURCE_TYPE_PLAYER)
	{
		if (wEventID == EVENT_PLAYER_LOGIN)
			OnPlayerLogin((IPlayer*)dwSrcID, pszContext, nLen);
	}
}

void CLuaGameEvent::OnPlayerLogin(IPlayer* pPlayer, LPCSTR pszContext, int nLen)
{
	CLuaParam input[1];
	input[0] = pPlayer->GetActorID();
	GetLuaModule()->RunFunction("OnPlayerLogin", input, 1, NULL, 0);
}

function OnPlayerLogin(actorID)
	-- 新手出生进副本
	local actorLv = GetPlayerNumProp(actorID, CREATURE_FIELD_LEVEL)
	if actorLv == 1 then
		local ectypeID = Lua_GetConstValue(CONST_NEWBIEECTYPE_ID)
		if ectypeID > 0 then
			EnterEctype(actorID, ectypeID)
		end
	end
end

function EnterEctype(actorID, ectypeID)
	local sceneID = Lua_CreateEctype(actorID, ectypeID)
	if Lua_ChangeGameScene(actorID, sceneID) == false then
		_warn("切换场景失败")
		return RESULT_COMMON_FAILURE
	end
	return RESULT_COMMON_SUCCEED
end
</pre>

	<hr />
	<h1>客户端热更机制</h1>
	<pre class="prettyprint linenums">
//Bootstrap.cs
public class Bootstrap : MonoBehaviour
{
	void Awake()
	{
		LoadWhoAmI();
	}
	void LoadWhoAmI()
	{
		//打包时写入文件Resources/whoami.txt
		var ta = Resources.Load<TextAsset>("whoami");
		var whoami = Json.Decode(ta.text) as Dictionary<string, object>;
		//包id
		GameLuaAPI.GameClientId = Convert.ToInt32(whoami["id"]);
		//查询url，伴随该包的整个生命周期
		GameLuaAPI.urlroot = whoami["urlroot"] as string;
		//根据上述url和包id，查询包配置参数
		StartCoroutine(LoadGameClientUrls());
	}
	IEnumerator LoadGameClientUrls()
	{
		HTTPRequest request = new HTTPRequest(new Uri($"{GameLuaAPI.urlroot}\\GetPackageConfig?packageid={GameLuaAPI.GameClientId}"));
		request.Send();
		yield return request;
		var r = Json.Decode(request.Response.DataAsText) as Dictionary<string, object>;
		GameLuaAPI.urlversion = r["versionurl"] as string;
		GameLuaAPI.urlab = r["aburl"] as string;
		GameLuaAPI.urllogin = r["loginurl"] as string;
		GameLuaAPI.urlreport = r["reporturl"] as string;
		GameLuaAPI.urlchargecallback = r["chargecallbackurl"] as string;
		GameLuaAPI.extra = r["extra"] as string;
		GameLuaAPI.GameId = Convert.ToInt32(r["gameid"]);
		GameLuaAPI.ChannelId = Convert.ToInt32(r["channelid"]);
		//开始加载全局组件
		AwakeImp_();
	}
	void AwakeImp_()
	{
		//1.加载资源服务器下assetbundle的version
		StartCoroutine(LoadVersionRemote());
	}
	IEnumerator LoadVersionRemote()
	{
		HTTPRequest request = new HTTPRequest(new Uri(GameLuaAPI.urlversion + $"?time={DateTimeOffset.UtcNow.ToUnixTimeSeconds()}"));
		request.Send();
		yield return request;
		XmlDocument doc = new XmlDocument();
		doc.Load(new XmlTextReader(new MemoryStream(request.Response.Data)));
		var root = doc.SelectSingleNode("root");
		XmlNodeList nl = root.ChildNodes;
		for (int i = 0; i != nl.Count; ++i)
		{
			XmlElement n = (XmlElement)nl.Item(i);
			var it = new HotResManager.Item();
			it.type = n.GetAttribute("type");
			it.name = n.GetAttribute("name");
			it.md5 = n.GetAttribute("md5");
			it.size = n.HasAttribute("size") ? Convert.ToInt32(n.GetAttribute("size")) : 0;
			it.ver = n.HasAttribute("ver") ? Convert.ToInt32(n.GetAttribute("ver")) : 0;
			it.actorlevel = n.HasAttribute("actorlevel") ? Convert.ToInt32(n.GetAttribute("actorlevel")) : 0;
			it.ab = null;

			HotResManager.items_.Add(it.name, it);
		}
		//加装streamingassests目录下的命名混淆映射
		yield return LoadABCodeUnderStreamingAssets("abcode.txt");
	}
	IEnumerator LoadABCodeUnderStreamingAssets(string name)
	{
		WWW www = new WWW(Path.Combine(HotResManager.WWW_STREAM_ASSET_PATH, name));
		yield return www;
		// 加载
		var sr = new StreamReader(new MemoryStream(www.bytes));
		while (sr.Peek() >= 0)
		{
			//解析ab名字映射
			var l = sr.ReadLine();
			var names = l.Split(',');

			HotResManager.abcodes_.Add(names[0], names[1]);
		}
		
		//2.加载streamingassets/version.xml
		yield return LoadVersionUnderStreamingAssets(GameLuaAPI.versionFileName);
	}

	IEnumerator LoadVersionUnderStreamingAssets(string name)
	{
		WWW www = new WWW(Path.Combine(HotResManager.WWW_STREAM_ASSET_PATH, HotResManager.DecodeStreamingAssetsFileName(name)));
		yield return www;
	
		// 加载
		XmlDocument doc = new XmlDocument();
		doc.Load(new XmlTextReader(new MemoryStream(www.bytes)));
		XmlNodeList nl = doc.SelectSingleNode("root").ChildNodes;
		for (int i = 0; i != nl.Count; ++i)
		{
			XmlElement n = (XmlElement)nl.Item(i);
			HotResManager.items_streamingassets_[n.GetAttribute("name")] = Convert.ToInt32(n.GetAttribute("ver"));
		}
		//3.加载PersistantDataPath/version.xml
		HotResManager.LoadVersionUnderPersistantDataPath(GameLuaAPI.versionFileName);
		//4.比较版本号，依次尝试定位，先streamingassets，次PersistantDataPath，最后WWW
		HotResManager.LocateAB();

		foreach (var v in HotResManager.items_)
		{
			HotResManager.Item it = v.Value;
			if (HotResManager.ePath.ePath_None == it.path && it.actorlevel == 0)
			{
				tResManager.items_need_download_.Add(it.name);
			}
		}
		// 去资源服下载吧
		if (HotResManager.items_need_download_.Count > 0)
		{
			HotResManager.BeginDownload();
			StartCoroutine(OnLoadAB());
		}
		else
		{
			HotFinished();
		}
	}
}
</pre>
	<pre class="prettyprint linenums">
public IEnumerator OnLoadAB()
{
	for (; ; )
	{
		if (HotResManager.items_need_download_.Count == 0
			&& HotResManager.items_downloading_.Count == 0)
		{
			break;
		}
		files_updatedSize = 0;
		foreach (var a in HotResManager.items_downloaded_)
		{
			files_updatedSize += HotResManager.items_[a].size;
		}
		foreach (var a in HotResManager.items_downloading_)
		{
			files_updatedSize += HotResManager.items_[a].bytesdownloaded;
		}
		TipsRatio(files_updatedSize, files_totalSize);
		yield return new WaitForSeconds(0.5f);
	}
	HotFinished();
}
private void HotFinished()
{
	if (PlayerPrefs.GetInt("DecodeAll", 0) == 0)
	{
		StartCoroutine(LoadABUnderStreamingAssets());
	}
	else
	{
		SilientDownloadAndGo();
	}
}
IEnumerator LoadABUnderStreamingAssets()
{
	var processed = 0;
	var index = 0;
	var tasks = new System.Threading.Tasks.Task[50];
	List<string> abs = new List<string>();
	foreach (var kv in HotResManager.items_streamingassets_)
	{
		TipsRatioDecode(++processed);
		if (PlayerPrefs.GetInt(kv.Key, 0) > 0)
		{
			continue;
		}
		var filepath = Path.Combine(HotResManager.WWW_STREAM_ASSET_PATH,
		$"{HotResManager.DecodeStreamingAssetsFileName(kv.Key)}@{kv.Value}.zip");
		WWW www = new WWW(filepath);
		yield return www;

		var data = www.bytes;
		tasks[index++] = System.Threading.Tasks.Task.Run(() =>
		{
			ZIPWrapper.DecompressFileLZMABytes(data,
			Path.Combine(HotResManager.persistentDataPath, kv.Key));
		});

		abs.Add(kv.Key);
		if (index >= tasks.Length)
		{
			System.Threading.Tasks.Task.WaitAll(tasks);
			abs.ForEach(x => PlayerPrefs.SetInt(x, 1));
			index = 0;
			abs.Clear();
		}
	}

	System.Threading.Tasks.Task.WaitAll(tasks);
	abs.ForEach(x => PlayerPrefs.SetInt(x, 1));
	//标识一下，全部解压完毕
	PlayerPrefs.SetInt("DecodeAll", 1);
	SilientDownloadAndGo();
}
private void SilientDownloadAndGo()
{
	//静默下载
	foreach (var v in HotResManager.items_)
	{
		HotResManager.Item it = v.Value;
		if (HotResManager.ePath.ePath_None == it.path)
		{
			HotResManager.items_need_download_.Add(it.name);
		}
	}
	if (HotResManager.items_need_download_.Count > 0)
	{
		//排序，根据角色等级需求
		HotResManager.SortAB();
		HotResManager.BeginDownload();
	}
	//全部热更完毕，进入场景
	HotResManager.Cache();
	System.GC.Collect();
	Go();
}
private void Go()
{
	LuaManager.Instance.RunLuaFile("Main");
	gameObject.AddComponent<LuaMonoBehavior>().RunLuaFile("SceneManager");
}
</pre>
	<pre class="prettyprint">
--main.lua
json = require("json")
require "protobuf/protobuf"
require "DGameText"
require "DGameColor"
require "DResultCode"
require "DEntityField"
require "DGameEnum"
require "DSchemeStruct"
require "schemes_pb"
require "DMsgmodule"
require "DLogicdata"
require "EventManager"

require "LoginModule"
require "WorldModule"
require "ChatModule"
require "DMsgModule"
require "EntityModule"
require "EmailModule"
require "FriendModule"
require "GameModule"
require "SocietyModule"
require "StoreModule"
require "AIModule"
require "Countrymodule"
require "RankModule"
require "LuaModule"
require "SkepModule"
require "AgentModule"

require "HelperL"
require "UIManager"
require "HeroController"
require "ModelUILC"
require "SensitiveWord"
require "UIRichText"
require "Schemes"
require "MiscDataCenter"
require "MixUICenter"
require "ActivityManager"
require "PlayRoomDataCenter"
require "CountryDataCenter"
require "OtherPlayerInfoDataCenter"
require "OperatingActivityDataCenter"
require "GlobalGameDataCenter"
</pre>
	<pre class="prettyprint linenums">
--SceneManager.lua
--初始化 载入第一个场景
function SceneManager.Awake()
	-- 接入SDK的包，已通过SDK自带的登录验证界面，直接过渡到选区界面
	if GameLuaAPI.HasSDK() then
		SceneManager.LoadSceneWithLoading('SelectZone', true, false)
	else
	-- 切换到登录界面
		SceneManager.LoadSceneWithLoading('LoginForm', true, false)
	end
end
</pre>
	<hr />
	<h1>运营</h1>
	素材
	icon
	loading
	logo
	场景原画
	角色原画
	系统UI截图 例如 升星 坐骑 羽翼 宠物 等
	特色截图 例如 国战 帮战 副本 boss战

	<hr />
	<h1 id="monster">数值</h1>
	mmorpg的玩家追求的是价值，而非玩法
	参考 张五常的《经济解释》，有假设，有验证，都归依于简单的假设
	统一度量衡，以元宝diamond核算价值（物品，技能，玩法，活动）
	<h2>战斗数值</h2>
	另一个假设，以战力power来衡量战斗属性，假设 power/diamond = 1，此比例系数可变
	\[
	power = attack + defense
	\]
	攻击(attack)和防御(defense)对于战力的贡献，是否权重一致？即
	\[
	\frac{attack}{defense}系数是否为一？还是可变
	\]
	如何衡量基础战斗属性？
	以伤害公式为黑盒子，每点战斗属性的变化，对攻击或者防御的贡献是多少？进而换算成战力，进而得到元宝

	<h2>经济数值</h2>
	道理一也！
	物品（道具）对战斗数值的影响几何？进而可以换算为元宝！
	计划经济也！是否可以实行市场经济，物价几何，交由玩家决定？
	<ul>
		<li>
			元宝
			<p>基本单位，1</p>
		</li>
		<li>
			战力
			<p>元宝战力比，可变，假设即可，例如1/6，即一元宝可以兑换6战力</p>
		</li>
		<li>
			绑定元宝
			<p>可变，假设即可，例如0.5</p>
		</li>
		<li>
			经验
			<p>
				经验满了可以升级，战力会提升，基于<a id="#PlayerBaseProp">PlayerBaseProp.csv</a>，随着等级的提升，
				需要的经验越来越多，呈指数级上升，而每升一级提升的战力几乎不变，所以经验的价值呈对数级下降
			</p>
		</li>
		<li>
			体力
			<p>
			</p>
		</li>
		<li>
			银两
			<p>
			</p>
		</li>
		<li>
			修为
			<p>
			</p>
		</li>
		<li>
			帮贡
			<p>
			</p>
		</li>
		<li>
			声望
			<p>
			</p>
		</li>
		<li>
			升星石
			<p>
				升星石价值 = 每次升星增加的战力 x 概率 / 升星石数量 / 元宝战力比
			</p>
		</li>
		<li>
			强化石
			<p>
			</p>
		</li>
		<li>
			神兵升星石
			<p>
			</p>
		</li>
		<li>
			神兵进阶石
			<p>
			</p>
		</li>
		<li>
			洗练石
			<p>
			</p>
		</li>
		<li>
			精炼石
			<p>
			</p>
		</li>
		<li>
			精炼石
			<p>
			</p>
		</li>
		<li>
			坐骑进阶丹
			<p>
			</p>
		</li>
		<li>
			仙器进阶丹
			<p>
			</p>
		</li>
		<li>
			突破宝箱
			<p>
			</p>
		</li>
	</ul>
	<h3>运营活动</h3>
	<hr />
	<h1 id="monster">摆怪</h1>
	monster/*.csv
	<ul>
		<li>ID</li>
		<li>MonsterID</li>
		<li>Type</li>
		<li>BirthDelay</li>
		<li>BirthPositonX</li>
		<li>BirthPositonY</li>
		<li>BirthPositonZ</li>
		<li>Face</li>
	</ul>
	<hr />
	<h1 id="Skill">技能</h1>
	Skill.csv
	<ul>
		<li>ID</li>
		<li>Type</li>
		<li>Name</li>
		<li>Tips</li>
		<li>AttackAnimation</li>
		<li>BehitAnimation</li>
		<li>ConditionParameter2</li>
		<li>Probability</li>
		<li>Frequency</li>
		<li>Action</li>
	</ul>
	符文，加buff
	SkillRune.csv
	<ul>
		<li>ID</li>
		<li>Name</li>
		<li>Tips</li>
		<li>Level</li>
		<li>BuffID</li>
		<li>BuffLevel</li>
		<li>BuffRate</li>
		<li>LearnGoodsID</li>
		<li>LearnGoodsNum</li>
	</ul>
	心法
	SkillPassive.csv
	<ul>
		<li>ID</li>
		<li>Type</li>
		<li>Level</li>
		<li>Tips</li>
		<li>HP</li>
		<li>Attack</li>
		<li>Defense</li>
		<li>PhysicsAttack</li>
		<li>MagicAttack</li>
		<li>PhysicsDefense </li>
		<li>MagicDefense </li>
		<li>CriticalStrike </li>
		<li>AntiCriticalStrike </li>
		<li>Parry </li>
		<li>AntiParry </li>
		<li>Dodge </li>
		<li>Hit </li>
		<li>Armor </li>
		<li>AntiArmor </li>
		<li>DamageReduction </li>
		<li>DamageAdd </li>
		<li>MoveSpeed </li>
		<li>AttackDefense </li>
	</ul>
	天赋
	SkillTalent.csv
	<ul>
		<li>ID</li>
		<li>Type</li>
		<li>Level</li>
		<li>Tips</li>
		<li>Name</li>
		<li>HP</li>
		<li>Attack</li>
		<li>Defense</li>
		<li>PhysicsAttack</li>
		<li>MagicAttack</li>
		<li>PhysicsDefense </li>
		<li>MagicDefense </li>
		<li>CriticalStrike </li>
		<li>AntiCriticalStrike </li>
		<li>Parry </li>
		<li>AntiParry </li>
		<li>Dodge </li>
		<li>Hit </li>
		<li>Armor </li>
		<li>AntiArmor </li>
		<li>DamageReduction </li>
		<li>DamageAdd </li>
		<li>MoveSpeed </li>
		<li>AttackDefense </li>
	</ul>
	<hr />







	<h1 id="AIEvent">AI</h1>
	AIEvent.csv
	<ul>
		<li>ID</li>
		<li>Tips</li>
		<li>Event</li>
		<li>EventParameter</li>
		<li>Condition</li>
		<li>ConditionParameter1</li>
		<li>ConditionParameter2</li>
		<li>Probability</li>
		<li>Frequency</li>
		<li>Action</li>
	</ul>
	AIConfig.csv
	<ul>
		<li>ID</li>
		<li>Tips</li>
		<li>Skillid</li>
	</ul>
	<hr />







	<h1 id="Creature">采集</h1>
	SCollecteCoor.csv
	SCollectPb.csv
	SCollecteRe.csv
	ActivityCollect.csv
	EquipCollect.csv
	<ul>
		<li>ID</li>
		<li>Name</li>
		<li>Prefab</li>
		<li>Scale</li>
	</ul>
	<hr />







	<h1 id="Creature">生物表</h1>
	Creature.csv
	<ul>
		<li>ID</li>
		<li>Name</li>
		<li>Prefab</li>
		<li>Scale</li>
	</ul>
	<hr />







	<h1 id="SceneNpc">Npc</h1>
	SceneNpc.csv
	<ul>
		<li>ID</li>
		<li>Name</li>
		<li>MapID</li>
		<li>
			CreatureID
			<a href="#Creature">
				生物表Id
			</a>
		</li>
		<li>PosX</li>
		<li>PosY</li>
		<li>PosZ</li>
		<li>Angle</li>
		<li>Talk</li>
	</ul>
	<hr />







	<h1 id="GameScene">场景</h1>
	GameScene.csv
	<ul>
		<li>ID</li>
		<li>MapName</li>
		<li>
			MapRes
			<p>
				Unity的场景文件
			</p>
		</li>
		<li>
			MusicID
			<p>
				<a href="#Sound">音效</a>
			</p>
		</li>
	</ul>
	<hr />







	<h1 id="Sound">音效</h1>
	Sound.csv
	<ul>
		<li>ID</li>
		<li>
			File
			<p>
				Unity的音效文件
			</p>
		</li>
		<li>Tips</li>
		<li>
			Volume
			<p>
				音量
			</p>
		</li>
	</ul>
	<hr />







	<h1 id="BroadCast">广播</h1>
	BroadCast.csv
	<ul>
		<li>
			BroadID
		</li>
		<li>
			Tips
		</li>
		<li>
			BroadcastTips
			<p>
				内容#!%UI界面ID;%等级设置;%mapID;%X坐标;%Y坐标;%Z坐标!#
			</p>
		</li>
		<li>
			Channel
			<p>
				频道(0:无(系统);1:系统广播;2:系统;3:小喇叭;4:世界;5:帮会;6:阵营;7:队伍)
			</p>
		</li>
	</ul>
	<hr />







	<h1>定时活动</h1>
	ActivityTime.csv
	<ul>
		<li>
			ActvID
		</li>
		<li>
			Name
		</li>
		<li>
			LoopType
			<p>
				循环类型（0:手动开启;1:每天;2:每周;3:每月;4:指定日期;5:开服活动;6:开服第几天开本活动;7:合服第几天开本活动）
			</p>
		</li>
		<li><a href="#BroadCast">Broadcast</a></li>
		<li>
			ActType
			<p>
				活动类型(1:开服;2:合服;3:精彩活动;4:普通节日活动，5节日活动-国庆活动，6节日活动-圣诞活动，7全民冲榜，8元旦活动，9春节活动)
			</p>
		</li>
	</ul>
	<hr />







	<h1>押镖</h1>
	<hr />







	<h1>充值</h1>
	<h2>充值卡</h2>
	玩家充值额度不是随意的，由N个固定的额度，不同的专服不同，在数据库DS.dbo.RechargeCard里配置，充值单位是分，充值额度记作rmb，例如6块钱会记作rmb=600
	<h2>元宝</h2>
	充值获得元宝，换算比例
	\[
	diamond = \frac{rmb}{10}
	\]
	<p>充值并非一定会给元宝，也可以给物品，或者某个活动的参与权。</p>
	<h2>VIP积分</h2>
	充值获得VIP积分，换算比例
	\[
	vipscore = \frac{rmb}{10}
	\]
	<p>充值并非一定会给VIP积分，例如<a href="#CountryFund">建国基金</a>。</p>
	<h2>VIP等级</h2>
	由VIP积分确定，换算由表格 VipValue.csv 控制
	<pre class="prettyprint">
 // 设置Vip积分
void CPlayer::SetVipScore(DWORD dwPropID, int nValue)
{
	if (dwPropID != PLAYER_FIELD_CURVIPSCORE)
	{
		return;
	}
	m_nNumProp[dwPropID] = nValue;
	CLuaParam input;
	input.SetType(SD_INTEGER);
	input = m_nNumProp[dwPropID];
	CLuaParam output;
	output.SetType(SD_INTEGER);
	if (GetLuaModule()->RunFunction("GetVIPLevel", &input, 1, &output, 1) == false)
	{
		return;
	}
	SetVIPLevel(PLAYER_FIELD_VIPLEVEL, output);
}

---------------------------------------------------------------------
-- 获取vip等级
--------------------------------------------------------------------
function GetVIPLevel( curScore )

	local vipScheme = Schemes.VipValue.Get(VIPID_LEVEL_EXP)

	for i=0,16 do
		if vipScheme['Vip'..i] then
			if curScore < vipScheme['Vip'..i] then

				return i - 1
			end
		end
	end

	return 15
end

enum VIPID
{
	VIPID_VALUE_NULL = 0,
	VIPID_LEVEL_EXP = 1,							// VIP等级对应经验
	VIPID_EVERYDAY_PRIZE = 2,						// VIP每日礼包奖励ID
	VIPID_LEVEL_PRIZE = 3,							// VIP等级礼包奖励ID
	VIPID_MIDAS_TOUCH_TIMES = 4,					// 玩家使用点金手次数
	VIPID_REFRESH_MONEYSTORE = 5,					// 银两商店刷新次数
	VIPID_REFRESH_PRESTIGESTORE = 6,				// 声望商店刷新次数
	VIPID_REFRESH_CLANSTORE = 7,					// 帮会商店刷新次数
	VIPID_REFRESH_SECRETSTORE1 = 8,					// 神秘商店1刷新次数
	VIPID_REFRESH_SECRETSTORE2 = 9,					// 神秘商店2刷新次数
	VIPID_REFRESH_SECRETSTORE3 = 10,				// 神秘商店3刷新次数
	VIPID_BOSS_SUMMON_TIMES = 11,					// 召唤世界Boss次数
	VIPID_BRANCH_CANBRIBE = 12,						// 日常任务可钻石完成
	VIPID_BRANCH_FREEREFRESH = 13,					// 日常任务免费刷新次数
	VIPID_BRANCH_CANBUYROUND = 14,					// 日常任务可购买的轮次
	VIPID_ARENAGAME_BUYTIMES = 15,					// 竞技场购买轮数
	VIPID_BANK_EXCHANGE_TIME = 16,					// 无用
	VIPID_SOCIETY_BUYREVIVE = 17,					// 帮会复活购买次数
	VIPID_PRACTICE_BUYADDMORAL = 18,				// 帮会修炼购买次数
	VIPID_ONLINE_BROAD_CAST = 19,					// 上线全服公告
	VIPID_ESCORT_QUALITY = 20,						// 押镖刷新初始品质-蓝色粮草车
	VIPID_LOOP_TASK_STAR = 21,						// 每日跑环任务永久3星以上
	VIPID_STORE_DISCOUNT = 22,						// 商城物品打折
	VIPID_FREE_OPEN_STORE = 23,						// 远程药店
	VIPID_SOCIETY_DISTRIBUTE = 24,					// 帮会贡献捐献
	VIPID_UP_STAR = 25,								// 装备升星成功率
	VIPID_ECTYPE_RESET = 26,						// 单人副本重置次数
	VIPID_FREE_FLY = 27,							// 免费飞行
	VIPID_HUNT_SOUL = 28,							// 免费猎魂次数
	VIPID_EQUIP_DOWNGRADE = 29,						// 装备强化失败不会降级
	VIPID_STORE = 30,								// VIP商城
	VIPID_FREE_POLISH_1 = 31,						// 免费洗练次数
	VIPID_FREE_POLISH_2 = 32,						// 免费精炼次数
	VIPID_GODWEAPON_UPSTAR = 33,					// 神兵升星成功率
	VIPID_SOCIETY_AUTOLOOP = 34,					// 帮会跑环自动任务(商店)
	VIPID_MARKET_BINDRATE = 35,						// 寄售绑定元宝概率
	VIPID_SOCIETY_ECTYPETOWER_RESETTIMES = 36,		// 帮会副本塔可重置次数
	VIPID_ECTYPETOWER_RESETTIMES = 37,				// 副本塔可重置次数
	VIPID_TURNTABLES_BUYTIMES = 38,					// 全民转盘购买次数
	VIPID_ENERGY_CANBUYTIMES = 39,					// 每天可购买体力次数
	VIPID_MATERIALECTYPE_RESETTIMES = 40,			// 重置材料副本次数
	VIPID_VALUE_MAXID,
};
</pre>
	<h2>充值活动</h2>
	<p>充值增加VIP积分，VIP等级由VIP积分确定</p>
	<hr />







	<h1 id="CountryFund">建国基金</h1>
	<hr />







	<h1>常量定义</h1>
	ConstValue.csv
	<pre class="prettyprint">
enum CONST_VALUE
{
	CONST_VALUE_NULL = 0,							// 空常数
	CONST_PLAYER_BORN_MAPID = 1,					// 人物出生地图ID
	CONST_SAVEDB_INTERVAL = 2,						// 人物存盘时间间隔
	CONST_DESTROY_DELAY = 3,						// 销毁角色对象延迟时间
	CONST_BROADCAST_TIME = 4,						// 停服广播持续时间
	CONST_BROADCAST_INTERVAL = 5,					// 停服广播时间间隔
	CONST_KICKOUT_NUM_ONCE = 6,						// 停服每秒踢出几个玩家
	CONST_WORLD_CHAT_LEVEL = 7,						// 世界聊天等级限制
	CONST_WORLD_CHAT_INTERVAL = 8,					// 世界聊天发送间隔
	CONST_TRUMPET_COST_DIAMOND = 9,					// 发送小喇叭消耗钻石
	CONST_TRUMPET_SPARE_WHEEL = 10,					// 发送小喇叭消耗替代物
	CONST_PLAYER_LOGOUT_DELAY = 11,					// 人物下线延迟时间
	CONST_SIGNIN_LEVEL_LIMIT = 12,					// 每日签到等级限制
	CONST_RESIGNIN_COST_DIAMOND = 13,				// 每日签到补签钻石消耗
	CONST_ARENAGAME_OPENLEVEL = 14,					// 竞技场玩法开放等级
	CONST_ARENAGAME_INTERVAL = 15,					// 竞技场被动挑战时间间隔
	CONST_ARENAGAME_TIMES_PRICE = 16,				// 竞技场挑购买次数价格
	CONST_REVIVE_COST_DIAMOND = 17,					// 副本复活钻石消耗
	CONST_ENERGY_RECOVERVALUE = 18,					// 体力恢复值
	CONST_ENERGY_CANHOLD_MAX = 19,					// 玩家可持有体力上限
	CONST_ENERGY_BUYONE_VALUE = 20,					// 购买一次获得的体力值
	CONST_ENERGY_FETCH_VALUE = 21,					// 购买领取体力获得的值
	CONST_BABEL_RESET_TIME = 22,					// 通天塔每天重置最大次数
	CONST_BRANCH_REFRESH_COST = 23,					// 刷新日常任务消耗钻石数
	CONST_BRANCH_BUYROUND_COST = 24,				// 购买一轮日常消耗钻石数
	CONST_CHIEF_INTERVAL = 25,						// 副本霸主挑战时间间隔
	CONST_LOTTERY_FREETIMES = 26,					// 每日金币抽奖免费次数
	CONST_LOTTERY_COSTMONEY = 27,					// 单次金币抽奖价格
	CONST_LOTTERY_COSTDIAMOND = 28,					// 单次钻石抽奖价格
	CONST_ARENAGAME_COOLTIME = 29,					// 竞技场主动挑战冷却时间
	CONST_ARENAGAME_COOLCOST = 30,					// 竞技场消除冷却时间花费
	CONST_ECTYPE_SWEEPITEM = 31,					// 扫荡券物品ID
	CONST_ECTYPE_SWEEPPRICE = 32,					// 扫荡券单价
	CONST_MAIL_LISTLENGTH = 33,						// 邮箱长度
	CONST_HELP_COST_DIAMOND = 34,					// 求助消耗元宝
	CONST_ESCORT_LIST_NUM = 35,						// 押镖镖车列表最大数目
	CONST_ESCORT_ATTACK_TIMES = 36,					// 押镖挑战最大次数
	CONST_ESCORT_ATTACK_DURATION = 37,				// 押镖挑战时间间隔
	CONST_ESCORT_BEROBBED_TIMES = 38,				// 押镖一次最大被劫次数
	CONST_ESCORT_DONE_TIMES = 39,					// 押镖最大次数
	CONST_ESCORT_ONCE_TIME = 40,					// 押镖时长
	CONST_ESCORT_ATTACKCD_COST = 41,				// 押镖挑战清CD消耗
	CONST_ESCORT_REFRESH_COST = 42,					// 押镖刷新星级消耗
	CONST_ESCORT_BEATTACK_DURATION = 43,			// 押镖被挑战时间间隔
	CONST_ESCORT_ALMOST_DONW_TIME = 44,				// 押镖最后4分钟不能被挑战
	CONST_TD_LEVEL_LIMIT = 45,						// TD等级限制
	CONST_SOCIETY_MEMBERTIME = 46,					// 帮会成员信息列表更新间隔
	CONST_SOCIETY_SAVEDB_INTERVAL = 47,				// 帮会存盘时间间隔
	CONST_SOCIETY_CREATELEVEL = 48,					// 创建帮会需要等级
	CONST_SOCIETY_JOINLEVEL = 49,					// 加入帮会需要等级
	CONST_SOCIETY_CREATECOST = 50,					// 创建帮会需要元宝
	CONST_SOCIETY_INCVITALITY = 51,					// 上线增加活跃度
	CONST_SOCIETY_DECVITALITY = 52,					// 每天下降活跃度百分比
	CONST_SOCIETY_VITALITYLIMIT = 53,				// 活跃度小于1000时自动解散帮会
	CONST_SOCIETY_SUCCEEDTIME = 54,					// 帮主离线两周可以继任帮主
	CONST_SOCIETY_SECONDLEADERNUM = 55,				// 副帮主人数
	CONST_SOCIETY_THIRDLEADERNUM = 56,				// 长老人数
	CONST_SOCIETY_SUCCEEDCOST = 57,					// 继承帮主扣帮会帮贡
	CONST_SOCIETY_GETLISTLEN = 58,					// 玩家获取帮会列表长度
	CONST_SOCIETY_VITALITYALARM = 59,				// 活跃度小于1500时提醒将会解散帮会
	CONST_SOCIETY_FEASTDURATION = 60,				// 帮会宴会时长
	CONST_SOCIETY_FEASTADD = 61,					// 帮会宴会恢复时长
	CONST_SOCIETY_FEASTTIMES = 62,					// 帮会宴会最大次数
	CONST_SOCIETY_MENBERNUM = 63,					// 帮会人数<=40
	CONST_SOCIETY_INFOLEN = 64,						// 宣言字数<=40
	CONST_LOGIN_LEVEL_LIMIT = 65,					// 累计登陆的等级限制
	CONST_EXPBOSS_DONENUM = 66,						// 十二灵场每日次数
	CONST_WORLD_SYNCTIME = 67,						// 时间同步间隔
	CONST_ESCORT_REFRESH_VIP = 68,					// 押镖刷新VIP等级
	CONST_CORNUCOPIA_REFRESH_VIP = 69,				// 庄园刷新VIP等级
	CONST_AUTO_FIGHT_LEVEL = 70,					// 自动战斗等级
	CONST_CORNUCOPIA_GET_DURATION = 71,				// 庄园每次埋宝的时间间隔
	CONST_ESCORT_FULLREFRESH_COST = 72,				// 押镖刷新满星消耗
	CONST_ESCORT_FULLREFRESH_VIP = 73,				// 押镖刷新满星VIP等级
	CONST_CORNUCOPIA_FULLREFRESH_COST = 74,			// 庄园刷新满星消耗
	CONST_CORNUCOPIA_FULLREFRESH_VIP = 75,			// 庄园刷新满星VIP等级
	CONST_GOLDBOSS_SOCIETYPRIZE_NUM = 76,			// 黄金BOSS帮会奖励数量
	CONST_GOLDBOSS_ENTERTIME = 77,					// 黄金BOSS主动进入间隔
	CONST_BATTLEGAME_CALLINTERVAL = 78,				// 帮会战斗召唤间隔
	CONST_BATTLEGAME_CALLVALIDTIME = 79,			// 帮会战斗召唤有效时间
	CONST_VIPSCORE_TIME_INTERVAL = 80,				// vip隔多长时间加经验
	CONST_PRACTICEGAME_DURATION = 81,				// 帮会修炼玩法时长
	CONST_PRACTICEGAME_BASEADDMORAL = 82,			// 帮会修炼玩法基础增加修为
	CONST_PRACTICEGAME_PLAYERADDMORAL = 83,			// 帮会修炼玩法购买增加个人修为
	CONST_PRACTICEGAME_SOCIETYADDMORAL = 84,		// 帮会修炼玩法购买增加帮会修为
	CONST_PRACTICEGAME_OPENTIMES = 85,				// 帮会修炼玩法开启次数
	CONST_MELEE_MINLEVEL = 86,						// 大乱斗的等级限制
	CONST_SOCIETY_INIT_VITALITY = 87,				// 帮会初始活跃度
	CONST_SOCIETY_INIT_FEASTLEAVE = 88,				// 帮会初始宴会次数
	CONST_MAIL_REFRESH_INTERVAL = 89,				// 邮箱强制刷新时间间隔
	CONST_BRANCH_TASK_BEST_VIPLIMIT = 90,			// 循环任务VIP8以上才能刷新到五星
	CONST_BRANCH_TASK_BEST_COST = 91,				// 循环任务VIP8以上，100元宝，直接刷新到五星
	CONST_LEVELUP_NOTE = 92,						// 提示升级等级
	CONST_LEVELUP_POPUP = 93,						// 弹框提示升级等级
	CONST_FARM_KING_PERCENT = 94,					// 农场国王加成
	CONST_FARM_PROTECTED_TIME = 95,					// 被抢保护时间
	CONST_FARM_ROBBEDTIMES_MAX = 96,				// 最大被抢差
	CONST_FARM_ROBTIMES_MAX = 97,					// 抢劫次数最大保存值
	CONST_FARM_RECOVERROB_MAX = 98,					// 抢劫次数最大恢复值
	CONST_FARM_RECOVERROB_DURATION = 99,			// 抢劫次数恢复时间
	CONST_FARM_GET_PROTECTED = 100,					// 农场收获前保护时间
	CONST_FARM_PLANT_VIP = 101,						// 农场VIP4能多种2个坑
	CONST_FARM_PLANT_VIPADD = 102,					// 农场VIP4能多种2个坑
	CONST_FARM_PLANTNUM_LEVEL1 = 103,				// 1级农场基本坑数
	CONST_FARM_PLANTNUM_LEVEL2 = 104,				// 2级农场基本坑数
	CONST_FARM_PLANTNUM_LEVEL3 = 105,               // 3级农场基本坑数
	CONST_FARM_PLANTNUM_LEVEL4 = 106,               // 4级农场基本坑数
	CONST_MELEEGAME_ENTER_INTERVAL = 107,           // 大乱斗进场间隔
	CONST_GAMESUGGEST_MAXLENGTH = 108,				// 游戏建议最大字数
	CONST_GAMESUGGEST_MINLENGTH = 109,				// 游戏建议至少字数
	CONST_LOTTERY_COSTDIAMONDLOGIN = 110,           //单次钻石登陆抽奖价格
	CONST_SUCCESSIONLOGIN_FIRST_LEVEL = 111,         //累计登陆抽奖次数达到200次
	CONST_SUCCESSIONLOGIN_SECOND_LEVEL = 112,       //累计登陆抽奖次数达到500次
	CONST_SUCCESSIONLOGIN_THREE_LEVEL = 113,        //累计登陆抽奖次数达到10000
	CONST_SELECT_COUNTRY_LEVEL_LIMIT = 114,			// 玩家选择国家阵营等级
	CONST_PACKET_DEFAULT_SIZE = 115,				// 背包格子默认数量
	CONST_WAREHORSE_DEFAULT_SIZE = 116,				// 默认仓库格子数量
	CONST_PACKET_TIDY_TIME_INTERVAL = 117,			// 背包刷新cd时间
	CONST_SOCIETY_SUCCEEDTRAIN = 118,				// 继任帮主帮贡最低要求
	CONST_SOCIETY_PRIZEDISTRIBUTE = 119,			//帮会分配间隔小时
	CONST_SOCIETY_DAYCOSTFOUNDBASE = 120,			//帮会每天扣资金基数
	CONST_SOCIETY_DISTRIBUTECOSTFOUNDBASE = 121,	//帮会奖励分配扣资金基数
	CONST_SOCIETY_MSGCACHENUM = 122,				//帮会消息记录数量
	CONST_SOCIETY_MAXAPPLYNUM = 123,				//帮会申请记录数量
	CONST_SOCIETY_DISTRIBUTENUM = 124,				//帮会分配记录数量
	CONST_EQUIPSPACIALSKILL_CD1 = 125,				//装备特技CD1
	CONST_EQUIPSPACIALSKILL_CD2 = 126,				//装备特技CD2
	CONST_EQUIPSPACIALSKILL_COSTGOOD = 127,			//装备特技CD2内消耗物
	CONST_EQUIPSPACIALSKILL_DAYTIMES = 128,			//装备特技每天次数
	CONST_BORNMAP_ID = 129,							//新手村地图ID
	CONST_REVIVE_COST_ITEM = 130,					//复活消耗物品
	CONST_REVIVE_COST_MAXNUM = 131,					//复活消耗物品上限
	CONST_SOCIETY_MAXEVENTINFO = 132,					//帮会事件记录最大记录条数
	CONST_WORLDLEVELUP_ADD	   = 133,				//世界等级附加常数值
	CONST_SOCIETY_ACTVCOLLECT_DURATION = 134,		//帮会采集活动开启持续时间(秒)
	CONST_ECTYPE_CRYSTALCAVE_ID = 135,				//水晶矿洞副本ID
	CONST_SOCIETY_CONTRIBUTION = 136,				// 帮会捐献消息数量
	CONST_REDBAGITEM_DIAMOND = 137,					// 红包道具抵元宝数量
	CONST_REDBAG_TIMES_LIMIT_WORLD = 138,			// 世界红包领取次数限制
	CONST_REDBAG_TIMES_LIMIT_SOCIETY = 139,			// 帮会红包领取次数限制
	CONST_REDBAG_SOCIETY_MIN_DIAMOND = 140,			// 帮会红包最低发送元宝数量
	CONST_REDBAG_VALID_TIME = 141,					// 红包有效时间
	CONST_ONTIME_VIPSCORE_PRIZE = 142,				// 在线x分钟增加X点VIP经验
	CONST_ONTIME_VIPSCORE_EVERYDAY = 143,			// 每日登陆增加x点vip经验
	CONST_CONSUME_DIAMOND_VIP_SCORE = 144,			// 消费1个元宝加x点vip经验
	CONST_CHARGE_DIAMOND_VIP_SCORE = 145,			// 充值1个元宝加x点vip经验
	CONST_GEMCREATE_FREECOUNT = 146,				// 猎魂免费次数
	CONST_GOODSAVE_NUM = 147,						// 每次存多少个物品
	CONST_GOODDELETE_NUM = 148,						// 每次删除多少个物品
	CONST_RETURNBORNMAP_TASKID = 149,				// 返回新手村最小任务ID
	CONST_SKILL_MAX = 150 ,							//天赋心法最大值
	CONST_PLAYER_PROTECT_LEVEL = 151,				// 新手保护等级
	CONST_BANK_UPSTAR = 152,				        // 钱庄刷星消耗元宝数
	CONST_CHAT_LEVEL = 153,							// 聊天等级
	CONST_CHAT_VIPLEVEL = 154,						// 聊天vip等级
	CONST_CUSTOMIZETITLE_STAERID = 155,				// 自定义称号开始ID
	CONST_CREATE_SOCIETY_DIAMOND = 156,				// 创建帮会消耗元宝
	CONST_REDUCE_ALCOHOL = 157,						// 每分钟减少醉酒
	CONST_PLAYER_CHANGENAME_GOODSID = 158,			// 改名卡物品ID
	CONST_TURNTABLE_FREE_TIMES = 159,				// 转盘免费次数
	CONST_MAX_AURA = 160,							// 灵气上限
	CONST_NEWWING_PROPERTY_MAXLEVEL = 161,			// 新翅膀属性丹最大等级
	CONST_INHERITRETURN_GOODSID = 162,				// 装备传承返还材料开始ID
	CONST_ALCHEMY_CHANGE_COST = 163,				// 设置帮会丹药BUFF消耗的帮派资金
	CONST_ALCHEMY_FREESPEEDUP_MAXTIME = 164,		// 最大炼丹普通帮助次数
	CONST_ALCHEMY_COSTSPEEDUP_MAXTIME = 165,		// 最大炼丹元宝帮助次数
	CONST_ALCHEMY_CHANGE_MAXWEEKTIME = 166,			// 炼丹BUFF转换一周最大次数
	CONST_PALACEBOSS_MAXTIRED = 167,				// 地宫BOSS的最大疲劳值
	CONST_ALCHEMY_PERDAY_MAXTIME = 168,				// 每日炼丹最大次数限制
	CONST_HMY_SOLDIER_INIT_SCORE = 169,				// 鸿门宴副本士兵积分或货币的初始值
	CONST_EAST_CITY_JACKPOT_INIT_DIAMOND = 170,		// 全民寻宝初始奖池元宝数量
	CONST_EAST_CITY_DRAW_MAX_COUNT = 171,			// 全民寻宝全服抽奖次数限制
	CONST_EAST_CITY_JACKPOT_ADD_VALUE = 172,		// 全民寻宝每抽一次奖增加的元宝
	CONST_EAST_CITY_DRAW_COUNT1 = 173,				// 全民寻宝第N次抽奖数值阶段1
	CONST_EAST_CITY_DRAW_COUNT2 = 174,				// 全民寻宝第N次抽奖数值阶段2
	CONST_EAST_CITY_DRAW_COUNT3 = 175,              // 全民寻宝第N次抽奖数值阶段3
	CONST_EAST_CITY_DRAW_COUNT4 = 176,              // 全民寻宝第N次抽奖数值阶段4
	CONST_EAST_CITY_PRIZE_COUNT1 = 177,				// 全民寻宝全服第N次奖励次数1
	CONST_EAST_CITY_PRIZE_COUNT2 = 178,             // 全民寻宝全服第N次奖励次数2
	CONST_EAST_CITY_PRIZE_COUNT3 = 179,             // 全民寻宝全服第N次奖励次数3
	CONST_SOCIETY_RED_PACKET_MAX = 180,             // 帮会红包每次活动能发的最大数量
	CONST_SOCIETY_RP_START_INTERVAL = 181,          // 帮会红包活动开启后间隔几秒后发红包
	CONST_EAST_CITY_ONCE_DIAMOND = 182,             // 全民寻宝单次抽奖花费元宝
	CONST_EAST_CITY_TEN_DIAMOND = 183,				// 全民寻宝十次抽奖花费元宝
	CONST_LL_PAGODA_ONCE_DIAMOND = 184,				// 玲珑宝塔单次抽奖花费元宝
	CONST_LL_PAGODA_TEN_DIAMOND = 185,				// 玲珑宝塔十次抽奖花费元宝
	CONST_LL_PAGODA_FIFTY_DIAMOND = 186,			// 玲珑宝塔五十次抽奖花费元宝
	CONST_SEVEN_COLOR_EGGS_DIAMOND = 187,			// 七彩扭蛋需要充值或消费的元宝
	CONST_BATTLESTATUS_TIME = 188,					// 战斗状态持续时间
	CONST_ANSWER_RIGHT_ADD_SCORE = 189,				// 每一道题答对增加的积分
	CONST_ANSWER_RANK_ADD_SCORE_1 = 190,			// 每一道题排名第一额外增加的积分
	CONST_ANSWER_RANK_ADD_SCORE_2 = 191,            // 每一道题排名第二额外增加的积分
	CONST_ANSWER_RANK_ADD_SCORE_3 = 192,            // 每一道题排名第三额外增加的积分
	CONST_ANSWER_RANK_ADD_SCORE_OTHER = 193,        // 每一道题排名第三之后增加的积分
	CONST_ANSWER_PLAYER_OPEN_LEVEL = 194,			// 答题活动玩家开放等级
	CONST_COMMONZONE_DEFAULTSCENE = 195,			// 公共区默认场景
	CONST_PLAYER_CHANGE_SEX_GOODSID = 196,			// 变性卡物品ID
	CONST_EAST_CITY_PRIZE_COUNT4 = 197,				// 全民寻宝全服第N次奖励次数4
	CONST_EAST_CITY_PRIZE_COUNT5 = 198,             // 全民寻宝全服第N次奖励次数5
	CONST_EAST_CITY_PRIZE_COUNT6 = 199,             // 全民寻宝全服第N次奖励次数6
	CONST_EAST_CITY_PRIZE_COUNT7 = 200,             // 全民寻宝全服第N次奖励次数7
	CONST_USE_EQUIPSKILL = 201,						// 使用装备技能
	CONST_SEVEN_COLOR_ONCE_DIAMOND = 202,			// 七彩扭蛋单次抽奖花费元宝
	CONST_SEVEN_COLOR_TEN_DIAMOND = 203,			// 七彩扭蛋十次抽奖花费元宝
	CONST_SEVEN_COLOR_HUNDRED_DIAMOND = 204,		// 七彩扭蛋一百次抽奖花费元宝
	CONST_LUCKY_DRAW_ONCE_DIAMOND = 205,			// 欢乐抽奖单次抽奖花费元宝
	CONST_LUCKY_DRAW_TEN_DIAMOND = 206,				// 欢乐抽奖十次抽奖花费元宝
	CONST_SURVIVAL_CHALLENGE_DIAMOND = 207,			// 生存挑战重置元宝
	CONST_SURVIVAL_CHALLENGE_LEVEL = 208,			// 生存挑战开启等级
	CONST_SURVIVAL_CHALLENGE_FREE_TIMES = 209,		// 生存挑战最大免费次数
	CONST_SURVIVAL_CHALLENGE_ECTYPEID = 210,		// 生存挑战副本ID
	CONST_USE_GENRE = 211,							// 是否使用流派
	CONST_GENRE_COOLINGTIME = 212,					// 流派冷却时间
	CONST_VALUE_MAXID,								// 最大常数ID
};
</pre>
	<hr />























	<h1>装备升星</h1>
	装备的属性：quality[0] star[0,10]
	每升星到10，品质会升一级，然后star归零，犹如十进制的十位与个位的关系

	<ul>
		<li>
			客户端请求 UIStarUp.lua
			<pre class="prettyprint">
				--升星按钮
				self.upStarBtn = trans:Find("BtnStarUp").gameObject
				...
				--订阅点击事件
				UIEventListener.Get(self.upStarBtn).onClick = UIUpStar.OnClickUpStarBtn
				...
				--升星按钮点击事件处理
				function UIUpStar.OnClickUpStarBtn(go) 
					...
					UIUpStar.RequestUpStar()
					...
				end
				--客户端请求升星
				UIUpStar.RequestUpStar = function ( bindFlag ,entity)
				...
					local str_req = string.format("LuaRequestEquipStarUp?equip=%s&type=%s&bindflag=%d&AutoBuy=%s",uid,0,bindFlag,autoBuy)
					LuaModule.RunLuaRequest(str_req,UIUpStar.EquipUpStarCallBack)
				...
				end
				--客户端请求执行服务器Lua函数
				function LuaModule.RunLuaRequest(request, callback)
					...
					local m = LuaMessage_pb.CS_Lua_RunRequest()
					m.LuaRequest = request
					Premier.Instance:GetNetwork():SendFromLua(ENDPOINT.ENDPOINT_GAMECLIENT,
						ENDPOINT.ENDPOINT_GAMESERVER,
						MSG_MODULEID.MSG_MODULEID_LUA,
						LuaMessage_pb.MSG_LUA_RUNREQUEST,
						m:SerializeToString())
					...
				end
			</pre>
		</li>
		<li>
			服务器处理
			<pre class="prettyprint">
--EquipForge.lua
--------------------------------------------------------------------
-- 玩家请求升星装备
-- example "LuaRequestEquipStarUp?equip=xxx&type=xxx&bindflag=xxx&AutoBuy=xxx"
--------------------------------------------------------------------
function LuaRequestEquipStarUp(actorID)
	local equip = GetRequestNumberParam("equip")
	local upType = GetRequestNumberParam("type")
	local bindFlag = GetRequestStringParam("bindflag")
	local AutoBuy = GetRequestNumberParam("AutoBuy")

	local goodsID = Lua_GetGoodsNumProp(equip, ENTITY_FIELD_ID)
	local goodsScheme = tolua.cast(Lua_GetEquipmentScheme(goodsID), "SEquipmentScheme")

	local equipLevel = goodsScheme.nUseLevel
	local quality = Lua_GetGoodsNumProp(equip, EQUIPMENT_FIELD_QUALITY)
	local starNum = Lua_GetGoodsNumProp(equip, EQUIPMENT_FIELD_STARNUM)
	local smeltScheme = tolua.cast(Lua_GetEquipSmelt(goodsScheme.wSmeltID, quality, starNum), "SEquipSmelt")
	
	-- 装备等级判断
	if equipLevel < smeltScheme.dwNeedEquipLevel then
		return RESULT_EQUIP_UPSTAR_EQUIPLEVEL_LIMIT
	end
	-- 角色等级判断
	if GetPlayerNumProp(actorID, CREATURE_FIELD_LEVEL) < smeltScheme.dwNeedActorLevel then
		return RESULT_COMMON_LACK_LEVEL
	end
	--升星封顶了
	if smeltScheme.byNextQuality == 0 and smeltScheme.byNextStarNum == 0 then
		return RESULT_EQUIP_UPSTAR_FULLLEVEL
	end

	--消耗银两
	SetPlayerNumProp(actorID, PLAYER_FIELD_MONEY, costMoney, RES_DESTROP_SMELT, goodsID, "装备升星消耗")

	--消耗物品
	RemoveGoodsByID(actorID, smeltScheme.nCostitemId, smeltScheme.nCostitemNum - BuyGoods, RES_DESTROP_SMELT, goodsID, "装备升星消耗") 


	--祝福值大于等于100表示成功
	local curLuck = Lua_GetGoodsNumProp(equip, EQUIPMENT_FIELD_CUSTOM)
	local addLuck = smeltScheme.dwMeltingNumber

	local doubleRate = 0
	local doubleFlag = 0
	
	--七日目标升星日
	if IsNewbieTargetDay(actorID, 1) then
		isSpecialDay = true
	end

	--特殊的日子，有20%几率祝福值翻倍
	if isSpecialDay then
		doubleRate = doubleRate + 20
	end

	local probability = 0  
	probability = VipGetUpStartProbability(actorID)
	--有VIP特权或是特权卡特权的，有5%几率祝福值翻倍
	if probability > 0 then
		doubleRate = doubleRate + 5	
	end
	
	if doubleRate > 0 then
		local randNum = Lua_GetRandomInt(1, 100)
		if randNum <= doubleRate then
			addLuck = addLuck * 2
			doubleFlag = 1
		end
	end
	
	local finalLuck = curLuck + addLuck
	if finalLuck >= 100 then
		succ = true
	end


	local strData = addLuck .. "+" .. doubleFlag
	if succ then
		return RESULT_COMMON_SUCCEED, strData
	else
		return RESULT_EQUIP_UPSTAR_FAIL, strData
	end
end                
			</pre>
		</li>
	</ul>
	<h1>装备强化</h1>
	装备的属性：quality[0] star[0,10]
	每升星到10，品质会升一级，然后star归零，犹如十进制的十位与个位的关系

	<ul>
		<li>
			客户端请求
			<pre class="prettyprint">
				--UIStrength.lua
				--强化按钮
				self.strengthBtn = trans:Find("BtnStrength").gameObject

				...
				--订阅点击事件
				UIEventListener.Get(self.strengthBtn).onClick = UIStrength.OnClickStrengthBtn
				...
				--强化
				UIStrength.OnClickStrengthBtn = function ( go )
					...
					UIStrength:RequestStrength()
				end

				--客户端请求强化
				UIStrength.RequestStrength = function ( bindFlag ,entity)
					...
					local str_req = string.format("LuaRequestSmeltEquip?equip=%s&type=%s&bindflag=%d&AutoBuy=%s",uid,0,bindFlag,autovalue)
					LuaModule.RunLuaRequest(str_req,UIStrength.EquipStrengthCallBack)
					...
				end

				--客户端请求执行服务器Lua函数
				function LuaModule.RunLuaRequest(request, callback)
					...
					local m = LuaMessage_pb.CS_Lua_RunRequest()
					m.LuaRequest = request
					Premier.Instance:GetNetwork():SendFromLua(ENDPOINT.ENDPOINT_GAMECLIENT,
						ENDPOINT.ENDPOINT_GAMESERVER,
						MSG_MODULEID.MSG_MODULEID_LUA,
						LuaMessage_pb.MSG_LUA_RUNREQUEST,
						m:SerializeToString())
					...
				end
			</pre>
		</li>
		<li>
			服务器处理
			<pre class="prettyprint">
			--EquipSmelt.lua
--------------------------------------------------------------------
-- 玩家请求强化装备
-- example "LuaRequestSmeltEquip?equip=xxx"
--------------------------------------------------------------------
function LuaRequestSmeltEquip(actorID)
	local equip = GetRequestNumberParam("equip")
	local bindFlag = GetRequestStringParam("bindflag")
	local AutoBuy = GetRequestNumberParam("AutoBuy")
	return PlayerRunSmeltEquip(actorID, equip,bindFlag,AutoBuy)
end

--------------------------------------------------------------------
-- 执行强化装备
--------------------------------------------------------------------
function PlayerRunSmeltEquip(actorID, equip,bindFlag,AutoBuy)
...
	local equipID = Lua_GetGoodsNumProp(equip, ENTITY_FIELD_ID)
	local curSmeltLevel = Lua_GetGoodsNumProp(equip, EQUIPMENT_FIELD_SMELTLEVEL)
	local goodsScheme = tolua.cast(Lua_GetEquipmentScheme(equipID), "SEquipmentScheme")
...
	local smeltBaseID = goodsScheme.dwSmeltBaseID
	local next_level = curSmeltLevel + 1
	local smeltBaseScheme = tolua.cast(Lua_GetEquipSmeltBase(smeltBaseID, next_level), "SEquipSmeltBase")
...
	-- 装备等级判断
	if goodsScheme.nUseLevel < smeltBaseScheme.dwNeedEquipLevel then
		return RESULT_EQUIP_UPSTAR_EQUIPLEVEL_LIMIT
	end
	-- 角色等级判断
	if GetPlayerNumProp(actorID, CREATURE_FIELD_LEVEL) < smeltBaseScheme.dwNeedActorLevel then
		return RESULT_COMMON_LACK_LEVEL
	end
...
	--消耗银两
	local costMoney = smeltBaseScheme.dwCostMoney
	local descMoney = -1 * math.abs(costMoney)
	SetPlayerNumProp(actorID, PLAYER_FIELD_MONEY, descMoney, RES_DESTROP_SMELT, equipID, "装备强化消耗")

	--消耗物品
	local costItem 	= {}
	local dwCostGoodNumber 	= {}
	for i=1,3 do
		costItem[i] = smeltBaseScheme.dwCostGoodID[i - 1] or 0
	end
	for i=1,3 do
		dwCostGoodNumber[i] = smeltBaseScheme.dwCostGoodNumber[i - 1] or 0
	end
	for i=1,3 do
		if 0 ~= costItem[i] and 0 ~= dwCostGoodNumber[i] and dwCostGoodNumber[i]-BuyGoods > 0 then
			RemoveGoodsByID(actorID, costItem[i], dwCostGoodNumber[i]-BuyGoods, RES_DESTROP_SMELT, equipID, "装备强化")
		end
	end

	--计算概率
	local succRate	= smeltBaseScheme.dwSuccRate
	local failRate	= smeltBaseScheme.dwFailRate
	
	--七日目标强化日,成功率翻倍
	if IsNewbieTargetDay(actorID, 2) then
		succRate = succRate * 2
	end	
	local succ = false
	local randNum = Lua_GetRandomInt(0,9999)
	if randNum <= succRate then
		succ = true
	end

	--强化祝福值
	local curLuck = Lua_GetGoodsNumProp(equip, EQUIPMENT_FIELD_ENCHLEVEL)
	local addLuck = smeltBaseScheme.nAddLuckValue
	--有VIP特权或是特权卡特权的，祝福值翻倍
	if VipOnStrengthFail(actorID) then
		addLuck = addLuck * 2
	end
	local finalLuck = curLuck + addLuck
	if finalLuck >= 100 then
		succ = true
	end

...
	if succ then
		--强化成功，幸运值清0
		Lua_SetGoodsNumProp(equip, EQUIPMENT_FIELD_ENCHLEVEL, 0)
		Lua_SetGoodsNumProp(equip, EQUIPMENT_FIELD_SMELTLEVEL, curSmeltLevel + 1)
	else
		--失败了加祝福值
		Lua_SetGoodsNumProp(equip, EQUIPMENT_FIELD_ENCHLEVEL, finalLuck)
		return RESULT_EQUIP_SMELT_FAIL, addLuck
	end
	return RESULT_COMMON_SUCCEED
end
			</pre>
		</li>
	</ul>
	<h1>装备开孔</h1>
	先开孔，后镶嵌
	<ul>
		<li>
			客户端请求
			<pre class="prettyprint">
	function UIInlay.SetStrengthItem(entity)
		UIInlay:Init(entity)
	end

--设置宝石item
function UIInlay.Init(self,entity)
		--获取部位
		local index = self.GetEquipGemPart(itemInfo.SubType)
		local gemData = EntityModule.hero.equipGemPartDataLC:Get(index)
		self.stoneItemScriptList = {}
		for i,v in ipairs(self.stoneItemObj) do
			self.SetStoneItem(v,gemData.HoleNum,gemData.GemID[i],i,index,itemInfo)
		end
end

	--装备类型 映射到 装备宝石类型
	function UIInlay.GetEquipGemPart(equipType)
		local index = 0
		if equipType <= 6 then
			index = equipType
		elseif equipType == 10 then
			index = 7
		elseif equipType == 11 then
			index = 8
		end
		return index
	end

function UIInlay.SetStoneItem(go,holeNum,gemID,holeID,index,itemInfo)
	local script = CreateStoneItem(go,UIInlay)
	script.Awake()
end
				--StoneItem.lua
function CreateStoneItem(gameObject,parentScrpt)
	local o = {}
				function o.Awake()
					UIEventListener.Get(o.gameObject).onClick = o.OnBtn
				end
				--开孔
				function o.OnBtn(go)
				   o.OpenHoleTips()
				end

				--打孔弹窗操作界面
				function o.OpenHoleTips()
					UIEventListener.Get(o.openHoleTips.confrim).onClick = function ()
						o.OpenHole()
					end 
				end

				--开孔
				function o.OpenHole()
					local str_req = string.format("LuaRequestActiveGemHole?equipIndex=%s&holeIndex=%s",o.index,o.holeID)
					LuaModule.RunLuaRequest(str_req,o.OpenHoleCallBack)
				end
	return o
end
				--客户端请求执行服务器Lua函数
				function LuaModule.RunLuaRequest(request, callback)
					...
					local m = LuaMessage_pb.CS_Lua_RunRequest()
					m.LuaRequest = request
					Premier.Instance:GetNetwork():SendFromLua(ENDPOINT.ENDPOINT_GAMECLIENT,
						ENDPOINT.ENDPOINT_GAMESERVER,
						MSG_MODULEID.MSG_MODULEID_LUA,
						LuaMessage_pb.MSG_LUA_RUNREQUEST,
						m:SerializeToString())
					...
				end
			</pre>
		</li>
		<li>
			服务器处理
			<pre class="prettyprint">
			--GemLogic.lua
--------------------------------------------------------------------
-- 玩家请求激活宝石孔
-- example "LuaRequestActiveGemHole?equipIndex=xxx&holeIndex=xxx"
--------------------------------------------------------------------
function LuaRequestActiveGemHole(actorID)
	local equipIndex = GetRequestNumberParam("equipIndex")
	local holeIndex = GetRequestNumberParam("holeIndex")

	if equipIndex < 1 or equipIndex > 8 then
		return RESULT_COMMON_FAILURE
	end

	--检测槽孔的序号是否存在
	local scheme = GetCsvConfig("Gemstone", holeIndex)
	if not scheme then
		_warn("激活宝石孔配置有误")
		return RESULT_COMMON_FAILURE
	end

	local curNum = Lua_GetEquipGemHoleNum(actorID, equipIndex - 1, holeIndex - 1)

	if GetPlayerNumProp(actorID, CREATURE_FIELD_LEVEL) < scheme.NeedLevel then
		return RESULT_COMMON_LACK_LEVEL
	end

	local costItem = scheme.NeedGoods
	local costNum = scheme.GoodsNumber
	local rate = 	scheme.Probability

	if Lua_GetGoodsCount(actorID, costItem) < costNum then
		return RESULT_COMMON_LACK_GOODS
	end

	if not RemoveGoodsByID(actorID, costItem, costNum, RES_CREATE_GEMINLAY, holeIndex, "激活宝石孔") then
		return RESULT_COMMON_ERROR
	end

	local randNum = math.random(0,9999)

	local succ = 0
	if randNum < rate then
		succ = 1
		Lua_SetEquipGemHoleNum(actorID, equipIndex - 1, holeIndex - 1, curNum + 1)
	end

	return RESULT_COMMON_SUCCEED, succ
end

/*获取装备位置开孔数
*/
BYTE Lua_GetEquipGemHoleNum(DWORD dwActorID, BYTE byEquipIndex, BYTE byHoleIndex)
{
	IPlayer* pPlayer = GPlayerManager()->GetPlayerByActorID(dwActorID);
	IFNULL_RETURN_ZERO(pPlayer);
	IGemPart* pGemPart = (IGemPart*)pPlayer->GetEntityPart(PLAYER_PARTID_GEM);
	IFNULL_RETURN_ZERO(pGemPart);
	return pGemPart->GetEquipGemHoleNum(byEquipIndex, byHoleIndex);
}

// 装备宝石孔 1-8 宝石绑定玩家装备位置不是每个装备
enum EQUIP_GEM_POS
{
	EQUIP_GEM_HEAD = 0,					// 头饰宝石1
	EQUIP_GEM_ARMOUR,					// 衣服宝石2
	EQUIP_GEM_SHOES,					// 鞋子宝石3
	EQUIP_GEM_PANTS,					// 裤子宝石4
	EQUIP_GEM_RING,						// 戒指宝石5
	EQUIP_GEM_NECKLACE,					// 项链宝石6
	EQUIP_GEM_NORMALWEAPON,				// 武器宝石10
	EQUIP_GEM_BELT,						// 腰带宝石11
	EQUIP_GEM_MAX,
};

enum GemstoneType
{
	GemstoneType_Null = 0,
	GemstoneType_Gem,		// 宝石镶嵌
	GemstoneType_Spirit,	// 魂石镶嵌
	GemstoneType_Max
};

// 获取装备位置开孔数
BYTE CGemPart::GetEquipGemHoleNum(BYTE byEquipIndex, BYTE byHoleIndex)
{
	if (byEquipIndex < EQUIP_GEM_HEAD || byEquipIndex >= EQUIP_GEM_MAX)
	{
		return 0;
	}

	const Gemstone_Item *pGemstoneItem = GetSchemeModule()->GetGemstoneItem(byHoleIndex+1);
	if (pGemstoneItem != NULL)
	{
		if (GemstoneType_Gem == pGemstoneItem->type())
		{
			// 宝石镶嵌
			return m_sEquipGemData[byEquipIndex].byHoleCount;
		}
		else if (GemstoneType_Spirit == pGemstoneItem->type())
		{
			// 魂石镶嵌
			return m_sEquipSpiritData[byEquipIndex].byHoleCount;
		}
	}

	return 0;
}
			</pre>
		</li>
	</ul>
	<h1>装备镶嵌</h1>
	<ul>
		<li>
			客户端请求
			<pre class="prettyprint">
--UIInlay.lua
--镶嵌按钮
self.InlayBtn = trans:Find("Container/InlayBtn").gameObject

UIEventListener.Get(self.InlayBtn).onClick = function()
	local str_req = string.format("LuaRequestPutOnGem?equipIndex=%d&holeIndex=%d&gemID=%d",self.equipIndex,self.holeID,self.GoodsID)
	LuaModule.RunLuaRequest(str_req,CALLBACK)
end

			</pre>
		</li>
		<li>
			服务器处理
			<pre class="prettyprint">
--GemLogic.lua
--------------------------------------------------------------------
-- 玩家请求镶嵌宝石
-- example "LuaRequestPutOnGem?equipIndex=xxx&holeIndex=xxx&gemID=xxx"
--------------------------------------------------------------------
function LuaRequestPutOnGem(actorID)
	local equipIndex = GetRequestNumberParam("equipIndex")
	local holeIndex = GetRequestNumberParam("holeIndex")
	local gemID = GetRequestNumberParam("gemID")

	local scheme = GetCsvConfig("Gemstone", holeIndex)

	local goodsScheme = tolua.cast(Lua_GetMedicamentScheme(gemID), "SMedicamentScheme")

	--消耗物品
	if not RemoveGoodsByID(actorID, gemID, 1, RES_CREATE_GEMINLAY, equipIndex *10 + holeIndex, "镶嵌宝石") then
		return RESULT_COMMON_ERROR
	end

	--旧宝石替换
	local oldGemID = Lua_GetEquipGemID(actorID, equipIndex - 1, holeIndex - 1)
	if oldGemID > 0 then
		AddGoodsByID(actorID, oldGemID, 1, RES_CREATE_GEMINLAY, oldGemID, "镶嵌宝石替换", 1)
	end

	Lua_SetEquipGemID(actorID, equipIndex - 1, holeIndex - 1, gemID)

	return RESULT_COMMON_SUCCEED
end
			</pre>
		</li>
	</ul>
	<h1>聊天</h1>
	<ul>
		<li>
			客户端部分
			<pre class="prettyprint">
Premier.Instance:RegisterLuaModule(MSG_MODULEID.MSG_MODULEID_CHAT, 'ChatModule.Handle')

function ChatModule.SendChatMsg(channel, inputStr, chatType)
	local msg = ChatMessage_pb.CS_Char_SendChat()
	msg.Channel = channel
	msg.Content = inputStr
	msg.ChatType = chatType
	Premier.Instance:GetNetwork():SendFromLua(ENDPOINT.ENDPOINT_GAMECLIENT,
		ENDPOINT.ENDPOINT_GAMESERVER,
		MSG_MODULEID.MSG_MODULEID_CHAT,
		ChatMessage_pb.MSG_CHAT_SENDCHAT,
		msg:SerializeToString())
end

</pre>
		</li>
		<li>
			服务器部分
			<pre class="prettyprint">
// 创建聊天模块
MODULE_API IServerModule* CreateChatModule(IGlobalProvider* pGlobalProvider)
{
	g_pChatModule = new CChatModule();
	if (g_pChatModule->Create() == false)
	{
		g_pChatModule->Release();
		g_pChatModule = NULL;
		return false;
	}
	return g_pChatModule;
}

// 创建
bool CChatModule::Create()
{
	IMessageDispatcher* pMsgDispatcher = Global->GetMessageDispatcher();
	IFNULL_RETURN_FALSE(pMsgDispatcher);
	pMsgDispatcher->RegisterMessage(MSG_MODULEID_CHAT, this);
	return true;
}

// 消息处理(不包含MsgHead)
void CChatModule::OnMessage(IPlayer* pPlayer, WORD wActionID, LPCSTR lpBuf, int nLen)
{
	switch (wActionID)
	{
	case MSG_CHAT_SENDCHAT:
		OnPlayerSendChat(pPlayer, lpBuf, nLen);
		break;
	default:
		break;
	}
}

// 玩家发送聊天信息
void CChatModule::OnPlayerSendChat(IPlayer* pPlayer, LPCSTR lpBuf, int nLen)
{
	CS_Char_SendChat request;
	if (!request.ParseFromArray(lpBuf, nLen))
	{
		_fileline();
		return;
	}
	if (request.channel() <= CHAT_CHANNEL_NULL || request.channel() >= CHAT_CHANNEL_MAXID)
	{
		_fileline();
		return;
	}
	// 聊天信息发送
	PlayerSendChat(pPlayer, request.channel(), request.content().c_str(), (CHAT_TYPE)request.chattype());
}

// 聊天频道
enum CHAT_CHANNEL
{
	CHAT_CHANNEL_NULL = 0,
	CHAT_CHANNEL_BROADCAST,					// 系统广播
	CHAT_CHANNEL_SYSTEM,					// 系统频道
	CHAT_CHANNEL_TRUMPET,					// 小喇叭
	CHAT_CHANNEL_WORLD,						// 世界频道
	CHAT_CHANNEL_SOCIETY,					// 帮会频道
	CHAT_CHANNEL_COUNTRY,					// 阵营频道
	CHAT_CHANNEL_TEAM,						// 队伍频道
	CHAT_CHANNEL_ROOM,						// 房间频道
	CHAT_CHANNEL_HELP,						// 求组频道
	CHAT_CHANNEL_GLOBALTRUMP,				// 全服喇叭频道
	CHAT_CHANNEL_MAXID,
};

// 玩家发送聊天信息
void CChatModule::PlayerSendChat(IPlayer* pPlayer, DWORD dwChannel, LPCSTR lpContent, CHAT_TYPE eType)
{
	CLuaParam input[3];
	input[0] = pPlayer->GetActorID();
	input[1] = dwChannel;
	input[2] = lpContent;
	CLuaParam output;
	if (GetLuaModule()->RunFunction("PlayerSendChat", input, 3, &output, 1) == false)
	{
		_error("CChatModule::PlayerSendChat run lua function false");
		return;
	}
	int result = output;
	switch (dwChannel)
	{
	case CHAT_CHANNEL_TRUMPET:
		SendTrumpetChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_WORLD:
		SendWorldChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_HELP:
		SendHelpChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_SOCIETY:
		SendSocietyChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_COUNTRY:
		SendCountryChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_TEAM:
		SendTeamChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_ROOM:
		SendRoomChat(pPlayer, lpContent, eType);
		break;
	case CHAT_CHANNEL_GLOBALTRUMP:
		SendGlobalTrumpChat(pPlayer, lpContent, eType);
		break;
	default:
		break;
	}
}

// 玩家发小喇叭
void CChatModule::SendTrumpetChat(IPlayer* pPlayer, LPCSTR lpContent, CHAT_TYPE eType)
{
	if (pPlayer == NULL || lpContent == NULL)
	{
		return;
	}
	SC_Char_SendChat message;
	message.set_channel(CHAT_CHANNEL_TRUMPET);
	message.set_senderid(pPlayer->GetActorID());
	message.set_sendername(pPlayer->GetName());
	message.set_content(lpContent);
	message.set_chattype(eType);
	message.set_sendervocation(pPlayer->GetNumProp(PLAYER_FIELD_VOCATION));
	message.set_sendercountry(pPlayer->GetNumProp(PLAYER_FIELD_COUNTRY));
	GPlayerManager()->BroadcastMsg(MSG_MODULEID_CHAT, MSG_CHAT_SENDCHAT, &message);
}

// 广播消息
void CPlayerManager::BroadcastMsg(WORD wKeyModule, WORD wKeyAction, IMessage* pMessage, UID uidExcept)
{
	static char	g_szSendBuff[MAX_SEND_BUFLEN];
	MsgHeadEx* pMsgHead = (MsgHeadEx*)g_szSendBuff;
	pMsgHead->head.bySrcPoint = ENDPOINT_GAMESERVER;
	pMsgHead->head.byDestPoint = ENDPOINT_GAMECLIENT;
	pMsgHead->head.wKeyModule = wKeyModule;
	pMsgHead->head.wKeyAction = wKeyAction;

	if (!pMessage->SerializeToArray(g_szSendBuff+sizeof(MsgHeadEx), sizeof(g_szSendBuff)-sizeof(MsgHeadEx)))
	{
		_error("CPlayerManager::BroadcastMsg wKeyAction=%d 序列化消息失败，描述：%s", wKeyAction, pMessage->Utf8DebugString());
		return;
	}
	int nSendLen = sizeof(MsgHeadEx) + pMessage->ByteSize();
	BroadcastData(g_szSendBuff, nSendLen, uidExcept);
}

// 广播数据
void CPlayerManager::BroadcastData(void* lpBuf, int nLen, UID uidExcept)
{
	LpPlayerList::iterator it = m_listOnlinePlayer.begin();
	for (; it != m_listOnlinePlayer.end(); ++it)
	{
		IPlayer* pPlayer = (*it);
		if (pPlayer == NULL || pPlayer->GetClinetID() == INVALID_CLIENT || pPlayer->GetUID() == uidExcept)
		{
			continue;
		}
		pPlayer->SendData(lpBuf, nLen);

	}
}

// 发送消息给玩家
void CPlayer::SendData(void* lpBuf, int nLen)
{
	m_pTerminalTunnel->SendData(lpBuf, nLen);
}

// 发送网络消息
void CTerminalTunnel::SendData(void* lpBuf, int nLen)
{
	auto p = (MsgHeadEx*)lpBuf;
	p->ex.dest.player.dwAgentID = m_dwAgentID;
	p->ex.dest.player.dwClientID = m_dwClientID;
	g_pGlobalProvider->GetCenterClient()->SendData((LPCSTR)lpBuf, nLen);
}
				</pre>
		</li>
	</ul>

	<h1>改名卡</h1>
	<ul>
		<li>
			配置物品
			<p>Medicament.csv</p>
		</li>
		<li>
			C++请求DB修改名字
			<pre class="prettyprint">
// 角色改名
bool CPlayerManager::SetPlayerName(DWORD dwActorID, LPCSTR szName)
{
	IDataClient *pDataClient = Global->GetDataClient();
	IFNULL_RETURN_FALSE(pDataClient);

	IPlayer *pPlayer = GetPlayerByActorID(dwActorID);
	IFNULL_RETURN_FALSE(pPlayer);

	DBINPUT_SAVE_ACTOR_NAME dbInput;
	dbInput.dwActorID = dwActorID;
	sstrcpyn(dbInput.szActorName, szName, sizeof(dbInput.szActorName));
	if (!pDataClient->ExecuteSP(SPID_SAVE_ACTOR_NAME, ServerZoneID, (LPCSTR)&dbInput, sizeof(dbInput), this))
	{
		_error("CPlayerManager::SetPlayerName");
		return false;
	}
	return true;
}
				</pre>
		</li>
		DB请求回调
		<li>
			<pre class="prettyprint">
void CPlayerManager::OnReturn(DWORD dwSpID, int nRetCode, DBKey dbKey, LPCSTR pOutData, int nOutLen)
{
	switch (dwSpID)
	{
	case SPID_SAVE_ACTOR_NAME:
		{
			if (pOutData == NULL || nOutLen < sizeof(DBOUTPUT_SAVE_ACTOR_NAME))
			{
				_error("CPlayerManager::OnReturn失败 SPID_SAVE_ACTOR_NAME nOutLen=%d", nOutLen);
				return;
			}

			DBOUTPUT_SAVE_ACTOR_NAME *pOutput = (DBOUTPUT_SAVE_ACTOR_NAME*)pOutData;
			IPlayer *pPlayer = GetPlayerByActorID(pOutput->dwActorID);
			IFNULL_RETURN(pPlayer);

			int nResult = 0;
			if (nRetCode != DBRET_CODE_SUCCEED)
			{
				// 改名失败
				nResult = 0;
			}
			else
			{
				// 改名成功
				nResult = 1;
				_info("角色-%s[%d] 改名为 %s", pPlayer->GetName(), pPlayer->GetActorID(), pOutput->szActorName);
				pPlayer->SetName(pOutput->szActorName);

				SC_Entity_Sync_Name msg;
				msg.set_entityuid(pPlayer->GetUID());
				msg.set_name(pOutput->szActorName);
				pPlayer->BroadcastData2NineGrid4(MSG_MODULEID_ENTITY, MSG_ENTITY_SYNCNAME, &msg);
			}

			// 调用lua
			CLuaParam input[3];
			input[0] = pPlayer->GetActorID();
			input[1] = nResult;
			input[2] = pOutput->szActorName;
			GetLuaModule()->RunFunction("OnActorChangeNameReturn", input, 3, NULL, 0);
		}
		break;
	default:
		_error("CPlayerManager::OnReturn 收到错误的数据库返回,dwSpID=%d", dwSpID);
		break;
	}
}
			</pre>
		</li>
		<li>
			封装接口，供lua调用
			<pre class="prettyprint">
//LuaGameAPI.cpp
// 角色改名
bool Lua_SetPlayerName(DWORD dwActorID, char *szName)
{
	return GPlayerManager()->SetPlayerName(dwActorID, szName);
}
				</pre>
		</li>
		服务器Lua处理客户端改名请求
		<li>
			<pre class="prettyprint">
local playerChangeNameTime = {}
--------------------------------------------------------------------
-- 请求改名
-- example LuaRequestChangeName?name=xxx
--------------------------------------------------------------------
function LuaRequestChangeName(actorID)
	local tarName = GetRequestStringParam("name")
	if string.len(tarName) < 2 then
		return RESULT_CREATEACTOR_NAMEINVALID
	end
	-- 判断cd
	local curTime = Lua_ServerTime()
	local lastTime = playerChangeNameTime[actorID]
	if lastTime then
		local deltaTime = curTime - lastTime
		if deltaTime >= 0 and deltaTime <= 24 * 60 * 60 then
			return RESULT_CHANGENAME_COOLING
		end
	end
	
	-- 判断物品
	local needGoodsID = Lua_GetConstValue(CONST_PLAYER_CHANGENAME_GOODSID)
	if needGoodsID <= 0 then
		_error('LuaRequestChangeName 没有配置改名卡物品ID')
		return RESULT_COMMON_ERROR
	end
	
	if Lua_GetGoodsCount(actorID, needGoodsID) == 0 then
		return RESULT_COMMON_LACK_GOODS
	end
	if not RemoveGoodsByID(actorID, needGoodsID, 1, RES_DESTROY_USE, needGoodsID, "改名卡") then
		_error(string.format('LuaRequestChangeName RemoveGoodsByID failed %s %s', actorID, needGoodsID))
		return RESULT_COMMON_LACK_GOODS
	end
	
	-- 记录cd
	if not Lua_SetPlayerName(actorID, tarName) then
		_warn('LuaRequestChangeName Lua_SetPlayerName failed')
		return RESULT_COMMON_ERROR
	end
	
	playerChangeNameTime[actorID] = curTime
	return RESULT_COMMON_SUCCEED
end

-- c++调用 修改名字结果
function OnActorChangeNameReturn(actorID, result, newName)
	if result == 1 then
		-- 成功
	else
		-- 失败
		-- 清空cd数据
		playerChangeNameTime[actorID] = nil
		-- 扣掉的物品补上
		local needGoodsID = Lua_GetConstValue(CONST_PLAYER_CHANGENAME_GOODSID)
		AddGoodsByID(actorID, needGoodsID, 1, RES_CREATE_USE, needGoodsID, "改名卡失败返还")
		
		Lua_ShowResultCode(actorID, RESULT_CREATEACTOR_NAMEEXISTS)
	end
end
				</pre>
		</li>
		<li>
			客户端改名请求
			<pre class="prettyprint">
--====================================改名对话框起始--=============================================
function MixUICenter.ShowChangeActorNameBox()
	local callback = function(info)
			if not info.inputField or not EntityModule.hero then
				return
			end
			if not HelperL.IsValidatePlayerName(info.inputField.value) then
				return true
			end
			if info.inputField.value == EntityModule.hero.name then
				HelperL.AddAMessageTip(GetGameText(luaID, 145))
				return true
			end
			local goodsID = Schemes.ConstValue.GetItemByID(CONST_VALUE.CONST_PLAYER_CHANGENAME_GOODSID).Value
			if not goodsID then
				return
			end
			local curGoodsNum = SkepModule.GetPacketSkep().Count(goodsID)
			if not curGoodsNum or curGoodsNum == 0 then
				local panel = info.boxObj:GetComponent('UIPanel')
				panel.depth = 100
				local newObj = GameObject.New()
				newObj.name = 'QuickBuyNode'
				newObj.layer = Layer.ZenUI
				newObj.transform:SetParent(info.boxObj.transform, false)
				HelperL.LoadQuickbuy(newObj, Vector3.zero, goodsID, nil)
				return true
			end
			if info.inputField then
				LuaModule.RunLuaRequest('LuaRequestChangeName?name='..info.inputField.value, HelperL.MessageTipCallBack)
			end
		end
	local btnInfoList = {}
	table.insert(btnInfoList, { name = GetGameText(luaID, 139), upperInfo = { text = GetGameText(luaID, 140) }, light = true, callbackFunc = callback })
	UIManager.AddMessageBOXCommon(EntityModule.hero.name, btnInfoList, nil, nil, nil, true)
end
--====================================改名对话框结束--=============================================
				</pre>
		</li>
	</ul>
	<hr />
	<h1>任务</h1>
	Task.csv
	<ul>
		<li>TaskID</li>
		<li>Name</li>
		<li>FollowTask</li>
		<li>AcceptNPC</li>
		<li>AcceptDialogue</li>
		<li>GiveNPC</li>
		<li>GiveDialogue</li>
		<li>PrizeID</li>
		<li>ChapterName</li>
	</ul>
	TaskBranch.csv

	<hr />
	<h1>副本</h1>
	Chapter.csv
	章节（包含N个同类型副本，例如坐骑副本，升星副本）
	<ul>
		<li>ChapID</li>
		<li>ChapName</li>
		<li>ChapType</li>
		<li>PrizeID</li>
	</ul>
	副本
	<ul>
		<li>EctypeID</li>
		<li>MapID</li>
		<li>EctypeTips</li>
		<li>PrizeID</li>
		<li>DropID</li>
		<li>NeedLvMin</li>
		<li>NeedLvMax</li>
	</ul>
	<h1>副本奖励</h1>
	PrizeEctype.csv
	<ul>
		<li>DropID</li>
		<li>Desc</li>
		<li>PrizeID</li>
	</ul>
	<h1>物品-常规</h1>
	Medicament.csv
	<ul>
		<li>
			GoodsID
			物品ID
		</li>
		<li>
			GroupID
			物品组ID
		</li>
		<li>
			GoodsName
			物品名称
		</li>
	</ul>
	<hr />







	<h1>物品-装备</h1>
	Equipment.csv
	<ul>
		<li>
			ID
			<p>物品ID</p>
		</li>
		<li>
			GoodsName
			<p>物品名字</p>
		</li>
		<li>
			PacketID
			<p>可放入的<a href="#PacketPart">背包部件</a>ID</p>
		</li>
		<li>
			IconID
			<p>物品图标</p>
		</li>
	</ul>
	<hr />







	<h1>运营活动</h1>
	<h1>定时奖励</h1>
	<h1>激活码</h1>
	<p></p>
	<ul>
		<li>
			ActivitionCode
			<p>激活码ID，唯一</p>
		</li>
		<li>
			GiftID
			<p>激活后，赠送的<a href="#ActivityGift">活动礼包</a>ID</p>
		</li>
		<li>
			Activity
			<p>活动分类，每个活动分类里，一个角色只能领取一次礼包，或者是，只能成功激活一个激活码</p>
		</li>
		<li>
			ActorID
			<p>成功激活这个激活码的玩家</p>
		</li>
		<li>
			CrtTime
			<p>激活码的创建时间</p>
		</li>
		<li>
			ExpireTime
			<p>激活码的过期时间</p>
		</li>
	</ul>
	<p>ActivitiesReward.lua</p>
	<pre class="prettyprint">
--客户端
-- 领取激活码礼包按钮
function UIActivities.GetActvCodePrize()
	local uiInput = UIActivities.selected_list[8].transform:Find("Panel/InputBox"):GetComponent('UIInput')
	local function OnGetActvCodeCallback(result,value)
		if result ~= RESULT_CODE.RESULT_COMMON_SUCCEED.id then
			HelperL.AddAMessageTip(HelperL.GetResultCodeStr(result))
		end
	end
	LuaModule.RunLuaRequest('LuaRequestGetActivityGift?giftID=0&code='..uiInput.value, OnGetActvCodeCallback)
end

--服务器验证
function LuaRequestGetActivityGift(actorID)
	-- 激活码礼包
	local activationCode = GetRequestStringParam("code")
	Lua_CheckActivitionCode(actorID, activationCode)
	return RESULT_COMMON_SUCCEED
end

void Lua_CheckActivitionCode(DWORD dwActorID, char* lpActivitionCode)
{
	GActivityGift()->CheckActivitionCode(dwActorID, lpActivitionCode);
}

/* 检测激活码
*/
void CActivityGift::CheckActivitionCode(DWORD dwActorID, LPCSTR lpActivitionCode)
{
	DBINPUT_ACTIVITIONCODE_CHECK dbInput;
	dbInput.dwActorID = dwActorID;
	sstrcpyn(dbInput.szActivitionCode, lpActivitionCode, sizeof(dbInput.szActivitionCode));
	IDataClient* pDataClient = Global->GetDataClient();
	IFNULL_RETURN(pDataClient);
	pDataClient->ExecuteSP(SPID_ACTIVITIONCODE_CHECK, dwActorID, (LPCSTR)&dbInput, sizeof(dbInput), this);
}

/* 数据库执行返回
*/
void CActivityGift::OnReturn(DWORD dwSpID, int nRetCode, DBKey dbKey, LPCSTR pOutData, int nOutLen)
{
	switch (dwSpID)
	{
	case SPID_ACTIVITIONCODE_CHECK:
		OnReturnActivitionCodeCheck(nRetCode, pOutData, nOutLen);
		break;
	default:
		break;
	}
}

// 激活码检测数据库返回
void CActivityGift::OnReturnActivitionCodeCheck(int nRetCode, LPCSTR pOutData, int nOutLen)
{
	DBOUTPUT_ACTIVITIONCODE_CHECK* pOutput = (DBOUTPUT_ACTIVITIONCODE_CHECK*)pOutData;
	CLuaParam input[3];
	input[0] = pOutput->dwActorID;
	input[1] = pOutput->dwGiftID;
	input[2] = nRetCode;
	GetLuaModule()->RunFunction("OnReturnActivitionCodeCheck", input, 3, NULL, 0);
}
--------------------------------------------------------------------
--  激活码检测返回
--------------------------------------------------------------------
function OnReturnActivitionCodeCheck(actorID, giftID, retCode)
	if retCode == 0 then
		local giftTable = GetCsvConfig("ActivityGift", giftID)
		local saveBigID = giftTable["SaveBigID"]
		local saveBitIndex = giftTable["SaveBitIndex"]
		local value = Lua_GetLogicData(actorID, saveBigID)
		if _getbit(value, saveBitIndex) == 1 then
			Lua_SendSystemResult(actorID, 0, RESULT_ACTIVITYGIFT_GETED)
			return
		end
		value = _setbit(value, saveBitIndex)
		Lua_SetLogicData(actorID, saveBigID, value)
		local prizeID = giftTable["PrizeID"]
		local giftName = giftTable["GiftName"]
		local prizes = GivePrizeToPacket(actorID, prizeID, RES_CREATE_GIFT, giftID, giftName)
		Lua_SendPrizeContent(actorID, 2, PrizeToString(prizes), giftName, "")
	elseif retCode == 10001 then
		Lua_SendSystemResult(actorID, 0, RESULT_ACTIVITIONCODE_INEXISTENT)
	elseif retCode == 10002 then
		Lua_SendSystemResult(actorID, 0, RESULT_ACTIVITIONCODE_USED)
	end
end

/* 发送奖励信息内容
*/
void Lua_SendPrizeContent(DWORD dwActorID, BYTE byFormType, char* lpPrizes, char* lpTitle, char* lpContent)
{
	GetChatModule()->SendPrizeContent(dwActorID, byFormType, lpPrizes, lpTitle, lpContent);
}

// 发送奖励信息内容
void CChatModule::SendPrizeContent(DWORD dwActorID, BYTE byFormType, char* lpPrizes, char* lpTitle, char* lpContent)
{
	IPlayer* pPlayer = GPlayerManager()->GetPlayerByActorID(dwActorID);
	if (pPlayer == NULL || !pPlayer->IsOnLine() || lpPrizes == NULL || lpTitle == NULL || lpContent == NULL)
	{
		return;
	}
	SC_Char_ShowPrizes message;
	message.set_formtype(byFormType);
	message.set_prizes(lpPrizes);
	message.set_title(lpTitle);
	message.set_content(lpContent);
	pPlayer->SendMessage(MSG_MODULEID_CHAT, MSG_CHAT_SHOWPRIZES, &message);
}

--------------------------------------------------------------------
-- 直接发放奖励给玩家
--------------------------------------------------------------------
function GivePrizeToPacket(actorID, prizeID, approach, param, desc, rate, forceBind)
	if approach == RES_CREATE_KILLMONSTER then
		local times = CheckPrizeAddRate(actorID, ADDRATE_PRIZETYPE_PRIZE, approach) + 1
		local prizes = nil
		for i = 1, times do
			prizes = givePrizeToPacket(actorID, prizeID, approach, param, desc, rate, forceBind)
		end
		return prizes
	else
		return givePrizeToPacket(actorID, prizeID, approach, param, desc, rate, forceBind)
	end
end

function givePrizeToPacket(actorID, prizeID, approach, param, desc, rate, forceBind)
	local failAddGoodList = {}
	for goodsID, goodsNum in pairs(prizes) do
		if goodsID >= VIRTUAL_GOODSID_BEGIN and goodsID <= VIRTUAL_GOODSID_CUR_MAX then
			SetPlayerNumProp(actorID, prizeStr[goodsID].playerField, goodsNum, approach, param, desc)
		else
			local result, _goodsID, _goodsNum, _bindFlag, _validTime = AddGoodsByID(actorID, goodsID, goodsNum, approach, param, desc, 0, true)
			if not result and _goodsID and _goodsNum and _bindFlag then
				table.insert(failAddGoodList, { id = _goodsID, num = _goodsNum, flag = _bindFlag, validTime = _validTime})
			end
		end
	end
	
	--失败了发邮件
	if #failAddGoodList > 0 then
		Lua_CreateNewEmail(title, content)
		for i,v in ipairs(failAddGoodList) do
			Lua_PushAdjunct(v.id, v.num, v.flag, v.validTime)
		end
		Lua_FlushEmail(actorID, 604800)
		Lua_SendSystemResult(actorID, 0, RESULT_EMAIL_LACK_PACKET)
	end
	
	return prizes,goodsBindFlag
end

--------------------------------------------------------------------
-- 添加角色物品封装
--------------------------------------------------------------------
function AddGoodsByID(actorID, goodsID, goodsNum, approach, param, desc, bindFlag, notAutoSendEmail, validTime)
	-- 绑定标志位
	bindFlag = bindFlag or 0
	-- 剩余时间
	validTime = validTime or 0
	local goodsScheme = tolua.cast(Lua_GetGoodsScheme(goodsID), "SGoodsScheme")
	-- 添加新神兵
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_GODWEAPON then
		if Lua_GetGodWeaponGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此神兵
			_warn("已经存在此神兵")
			return false
		else
			local newEquipUID = Lua_AddGodWeaponByID(actorID, goodsID, approach, param, desc)
			-- 自动佩戴新神兵
			Lua_SetTakenGodWeapon(actorID, newEquipUID)
			return true
		end
	end

	-- 添加怪物卡牌
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_MONSTERCARD then
		if Lua_GetCardGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此卡牌
			return false
		else
			if not Lua_AddMonsterCardByID(actorID, goodsID, approach, param, desc) then
				_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,怪物卡牌栏已满")
				return false
			end
			return true
		end
	end

	-- 添加坐骑
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_MOUNT then
		if Lua_GetMountGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此坐骑
			return AddEquipCommonSmeltLevel(actorID, goodsID, 1, goodsNum, approach, param, desc, bindFlag)
		else
			if not Lua_AddMountByID(actorID, goodsID, approach, param, desc, validTime) then
				_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能坐骑栏已满")
				return false
			end
			return true
		end
	end

	-- 添加翅膀(仙器)
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_WING then
		if Lua_GetWingGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此翅膀
			return AddEquipCommonSmeltLevel(actorID, goodsID, 2, goodsNum, approach, param, desc, bindFlag)
		else
			if not Lua_AddWingByID(actorID, goodsID, approach, param, desc) then
				_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能仙器栏已满")
				return false
			end
			return true
		end
	end

	-- 添加新翅膀
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_NEWWING then
		if Lua_GetNewWingGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此翅膀
			_warn("已经存在此翅膀")
			return false
		else
			if not Lua_AddNewWingByID(actorID, goodsID, approach, param, desc) then
				_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能新翅膀栏已满")
				return false
			end
			return true
		end
	end

	-- 添加新通用外显
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_AVATAR then
		if Lua_CheckHasAvatarEquip(actorID, goodsID) then
			return AddAvatarEquipSmeltLevel(actorID, goodsID, goodsNum, approach, param, desc, bindFlag)
		else
			local newEquipUID = Lua_AddAvatarByID(actorID, goodsID, approach, param, desc, 0)
			if math.tointeger(newEquipUID) == INVALID_UID then
				_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能外显装备栏已满")
				return false
			end
			return true
		end
	end
	
	-- 添加时装  (当添加时装时，goodsNum填有效期，0表示永久，单位小时)
	if goodsScheme.dwEntityClass == ENTITY_CLASS_EQUIPMENT and goodsScheme.nSubType == EQUIP_TYPE_FASHION then
		if Lua_GetFashionGoodsCount(actorID, goodsID) >= 1 then -- 已经存在此时装			
			if Lua_IsForeverFashionGoods(actorID, goodsID) then --判断是否为永久
				if goodsNum > 0 then
					_warn('该时装已经永久激活，限时的时装不能用了goodsID='..goodsID..',Time='..goodsNum)
					return false
				else
					--加时装的祝福值
					return AddFashionLuck(actorID, goodsID, goodsScheme.wSmeltID)
				end
			end
		end
		if not Lua_AddFashionByID(actorID, goodsID, goodsNum, approach, param, desc) then
			_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能时装栏已满")
			return false
		end
		return true
	end
	if goodsScheme.nPacketID == SKEPID_GEMPACK or goodsScheme.nPacketID == SKEPID_GEMSTORAGE then
		local emptyCount = Lua_GetGemEmptyCount(actorID, SKEPID_GEMSTORAGE)
		if emptyCount < math.ceil(goodsNum / goodsScheme.nPileQty) then
			local title = GetGameText(24)
			local content = GetGameText(28)
			Lua_CreateNewEmail(title, content)
			Lua_PushAdjunct(goodsID, goodsNum, bindFlag)
			Lua_FlushEmail(actorID, 604800)
			Lua_SendSystemResult(actorID, 0, RESULT_EMAIL_LACK_GEMSTORAGE)
			return true
		end
		if not Lua_AddGemByID(SKEPID_GEMSTORAGE, actorID, goodsID, goodsNum, approach, param, desc) then
			_error("添加角色["..actorID.."]宝石["..goodsID.."] * "..goodsNum.." 失败,可能背包已满")
			return false
		end
		return true
	end

	local emptyCount = Lua_GetEmptyCount(actorID, goodsScheme.nPacketID)
	if emptyCount < math.ceil(goodsNum / goodsScheme.nPileQty) then
		if not notAutoSendEmail then
			local title = GetGameText(24)
			local content = GetGameText(25)
			Lua_CreateNewEmail(title, content)
			Lua_PushAdjunct(goodsID, goodsNum, bindFlag, validTime)
			Lua_FlushEmail(actorID, 604800)
			Lua_SendSystemResult(actorID, 0, RESULT_EMAIL_LACK_PACKET)
			return true
		else
			return false, goodsID, goodsNum, bindFlag, validTime
		end
	end

	if not Lua_AddGoodsByID(actorID, goodsID, goodsNum, approach, param, desc, bindFlag, validTime) then
		_error("添加角色["..actorID.."]物品["..goodsID.."] * "..goodsNum.." 失败,可能背包已满")
		return false
	end
	return true
end

/* 添加物品
*/
bool Lua_AddGoodsByID(DWORD dwActorID, DWORD dwGoodsID, int nGoodsNum, DWORD dwApproach, DWORD dwParam, char* lpDesc, BYTE byBindFlag, int nValidTime)
{
	IPlayer* pPlayer = GPlayerManager()->GetPlayerByActorID(dwActorID);
	IPacketPart* pPacketPart = (IPacketPart*)pPlayer->GetEntityPart(PLAYER_PARTID_PACKET);
	return pPacketPart->AddGoodsByID(dwGoodsID, nGoodsNum, dwApproach, dwParam, lpDesc, byBindFlag, nValidTime);
}

// 添加物品
bool CPacketPart::AddGoodsByID(DWORD dwGoodsID, int nGoodsNum, DWORD dwApproach, DWORD dwParam, LPCSTR lpDesc, BYTE byBindFlag, int nValidTime)
{
	return m_SkepGroup.AddGoods(dwGoodsID, nGoodsNum, dwApproach, dwParam, lpDesc, byBindFlag, nValidTime);
}

// 添加物品
bool CSkepGroup::AddGoods(DWORD dwGoodsID, int nGoodsNum, DWORD dwApproach, DWORD dwParam, LPCSTR lpDesc, BYTE byBindFlag /*= 0*/, int nValidTime /*= 0*/)
{
	SGoodsScheme* pGoodsScheme = GetSchemeModule()->GetGoodsScheme(dwGoodsID);
	IFNULL_RETURN_FALSE(pGoodsScheme);
	while (nGoodsNum > 0)
	{
		int nCreateNum = nGoodsNum > pGoodsScheme->nPileQty ? pGoodsScheme->nPileQty : nGoodsNum;
		nGoodsNum -= nCreateNum;
		SBuildGoods sBuildGoods;
		sBuildGoods.dwGoodsID = dwGoodsID;
		sBuildGoods.nGoodsQty = nCreateNum;
		sBuildGoods.nValidTime = nValidTime;
		IEntity* pGoodsEntity = GetEntityModule()->BuildEntity(pGoodsScheme->dwEntityClass, (LPCSTR)&sBuildGoods, sizeof(sBuildGoods));
				
		if (pGoodsEntity == NULL)
		{
			return false;
		}
		if (AddGoods(pGoodsEntity->GetUID(), dwApproach, dwParam, lpDesc, byBindFlag) == INVALID_UID)
		{
			pGoodsEntity->Restore();
			return false;
		}
	}
	return true;
}

// 添加物品
UID CSkepGroup::AddGoods(UID uidGoods, DWORD dwApproach, DWORD dwParam, LPCSTR lpDesc, BYTE byBindFlag /*= 0*/)
{
	IEntity* pAddGoods = GetEntityModule()->GetGoodsByUID(uidGoods);
	// 增加绑定标志位
	if (pAddGoods->GetClass() == ENTITY_CLASS_MEDICAMENT) 
	{
		CMedicament* pMedicament = (CMedicament*)pAddGoods;
		pMedicament->SetFlag(byBindFlag);
	}
	else if (pAddGoods->GetClass() == ENTITY_CLASS_EQUIPMENT) 
	{
		CEquipment* pEquipment = (CEquipment*)pAddGoods;
		pEquipment->SetFlag(byBindFlag);
	}

	int nGoodsNum = pAddGoods->GetNumProp(GOODS_FIELD_QTY);
	SkepDataMap::iterator it = m_mapSkepData.begin();
	for (; it != m_mapSkepData.end(); ++it)
	{
		IGoodsSkep* pGoodsSkep = it->second.pGoodsSkep;
		if (pGoodsSkep == NULL)
		{
			continue;
		}
		if (pGoodsSkep->CanAddGoods(m_pMaster->GetUID(), uidGoods) != RESULT_COMMON_SUCCEED)
		{
			continue;
		}
		if (pGoodsSkep->AddGoods(m_pMaster->GetUID(), uidGoods, true))
		{
			IEntity* pGoodsEntity = GetEntityModule()->GetGoodsByUID(uidGoods);
			// 记录日志
			DBRESULTSET_GOODS sContext;
			int nContextLen = sizeof(sContext);
			if (pGoodsEntity->ExportDBContext((LPSTR)&sContext, nContextLen))
			{
				GetLogModule()->LogAddGoods(m_pMaster->GetActorID(), nGoodsNum, (LPCSTR)&sContext, nContextLen, dwApproach, dwParam, lpDesc);
			}
			return uidGoods;
		}
	}
	return INVALID_UID;
}

// 添加物品(若被合并则销毁)
bool CGoodsSkep::AddGoods(UID uidPlayer, UID& uidGoods, bool createEntity, int nPlace)
{
	IEventEngine* pEventEngine = Global->GetEventEngine();
	IGoods* pAddGoods = GetEntityModule()->GetGoodsByUID(uidGoods);
	SGoodsScheme* pGoodsScheme = pAddGoods->GetGoodsScheme();
	DWORD dwGoodsID = (DWORD)pAddGoods->GetNumProp(ENTITY_FIELD_ID);
	int nGoodsQty = pAddGoods->GetNumProp(GOODS_FIELD_QTY);
	// 如果自动找位置，并且有合并权限，要检查是否可以合并
	if(nPlace == ANYWHERE && pGoodsScheme->nPileQty > 1 && m_AccessManager.HasAccess(uidPlayer, SKEP_ACCESS_UNITE))
	{
		for(DWORD i = 0; i < m_dwMaxSize; i++)
		{
			IGoods* pGoods = GetSkepGoods(i);
			if(pGoods == NULL || (DWORD)pGoods->GetNumProp(ENTITY_FIELD_ID) != dwGoodsID)
			{
				continue;
			}

			// 绑定标志不相同
			if(pGoods->GetFlag() != pAddGoods->GetFlag())
			{
				continue;
			}

			// 有效期不相同
			if (pGoods->GetNumProp(GOODS_FIELD_VALIDTIME) != pAddGoods->GetNumProp(GOODS_FIELD_VALIDTIME))
			{
				continue;
			}

			// 可叠加数量不足
			if((pGoods->GetNumProp(GOODS_FIELD_QTY) + nGoodsQty) > pGoodsScheme->nPileQty)
			{
				continue;
			}

			// 修改物品数量
			pGoods->SetNumProp(GOODS_FIELD_QTY, nGoodsQty);
			return true;
		}
	}

	if(nPlace == ANYWHERE)
	{
		nPlace = FindEmptyPlace();
	}
	else
	{
		if(nPlace >= (int)m_dwValidSize || nPlace >= (int)m_dwMaxSize || GetSkepGoods(nPlace) != NULL)
		{
			return false;
		}
	}

	PutInGoods(uidGoods, nPlace);
	
	if (createEntity)
	{
		CreateClientGoods(uidGoods);
		AddGoodsObserver(pAddGoods);
	}
	return true;
}

// 将物品放入篮子
void CGoodsSkep::PutInGoods(UID uidGoods, int nPlace, bool bInit)
{
	IGoods* pGoods = GetEntityModule()->GetGoodsByUID(uidGoods);
	m_vecSkepGoods[nPlace] = uidGoods;
	pGoods->SetNumProp(GOODS_FIELD_SKEPID, (int)m_dwSkepID);
	pGoods->SetNumProp(GOODS_FIELD_PLACE, (int)nPlace);
}
</pre>
	<hr />
	<h1 id="ActivityGift">活动礼包</h1>
	ActivityGift.csv
	<ul>
		<li>
			GiftID
			<p>礼包ID</p>
		</li>
		<li>
			GiftName
			<p>礼包名字</p>
		</li>
		<li>
			PrizeID
			<p><a href="#PrizeTable">奖励</a>ID</p>
		</li>
		<li>
			SaveBigID
			<p>Logic部件的int</p>
		</li>
		<li>
			SaveBitIndex
			<p>Logic部件的int的bit</p>
		</li>
	</ul>
	<hr />







	<h1 id="PrizeTable">奖励</h1>
	PrizeTable
	<ul>
		<li>
			ID
			<p>奖励ID</p>
		</li>
		<li>
			Desc
			<p>描述</p>
		</li>
		<li>
			Goods
			<a href="#Prize">奖励</a>ID
		</li>
	</ul>

	<hr />
	<h1 id="PlayerBaseProp">角色等级基础属性</h1>
	PlayerBaseProp.csv
	<ul>
		<li>Level</li>
		<li>LevelExp</li>
		<li>VIP</li>
		<li>战斗力</li>
		<li>经验</li>
	</ul>
	<hr />
	<h1>角色属性</h1>
	<p>非战斗属性</p>
	<ul>
		<li>国家</li>
		<li>等级</li>
		<li>VIP</li>
		<li>战斗力</li>
		<li>经验</li>
	</ul>
	<p>战斗属性</p>
	<ul>
		<li>生命</li>
		<li>攻击</li>
		<li>防御</li>
		<li>物攻</li>
		<li>法攻</li>
		<li>物防</li>
		<li>法防</li>
		<li>暴击</li>
		<li>防爆</li>
		<li>格挡</li>
		<li>穿透</li>
		<li>闪避</li>
		<li>命中</li>
		<li>破甲</li>
		与伤害无关，用于击退
		<li>护甲</li>
		与伤害无关，用于击退
		<li>减伤</li>
		<li>加伤</li>
		<li>移动速度</li>
		<li>攻防全属性</li>
		<li>伤害点数</li>
		<li>攻击百分比</li>
		<li>忽视防御</li>
		<li>忽视防御百分比</li>
	</ul>
	<hr />







	<h1>战力</h1>
	<h2>战力系数</h2>
	<pre class="prettyprint">
	enum POWER_COEF
	{
		POWER_COEF_HP = 5,				        // 每点生命上限增加战斗力
		POWER_COEF_ATK = 100,                   // 每点攻击增加战斗力
		POWER_COEF_DEF = 200,				    // 每点防御增加战斗力
		POWER_COEF_PATK = 100,				    // 每点物理攻击增加战斗力
		POWER_COEF_MATK = 100,				    // 每点魔法攻击增加战斗力
		POWER_COEF_PDEF = 100,				    // 每点物理防御增加战斗力
		POWER_COEF_MDEF = 100,				    // 每点魔法防御增加战斗力
		POWER_COEF_CRITICAL_STRIKE = 1000,				// 每点暴击增加战斗力
		POWER_COEF_ANTI_CRITICAL_STRIKE = 1000,				// 每点防暴增加战斗力
		POWER_COEF_PARRY = 1000,				// 每点格挡增加战斗力
		POWER_COEF_ANTI_PARRY = 1000,				// 每点穿透增加战斗力
		POWER_COEF_DODGE = 1000,				// 每点闪避增加战斗力
		POWER_COEF_HIT = 1000,				// 每点命中增加战斗力
		POWER_COEF_ARMOR = 0,				// 每点护甲增加战斗力
		POWER_COEF_ANTI_ARMOR = 0,				// 每点破甲增加战斗力
		POWER_COEF_DAMAGE_REDUCTION = 100,				// 每点减伤增加战斗力
		POWER_COEF_DAMAGE_ADD = 100,				// 每点伤害加深增加战斗力
		POWER_COEF_SPD = 0,				// 每点移动速度增加战斗力
		POWER_COEF_ATK_DEF = 300,				// 每点全攻全防增加战斗力
		POWER_COEF_RATE = 5,				// 战斗力计算放大倍数
	};
	</pre>

	<h2>战力构成</h2>
	<p>由角色战斗属性乘以权重叠加而成</p>
	<pre class="prettyprint">
	int nPower =  m_nLevelPower + m_nEmblemPower + m_nMilitaryPower;
	for (int i = PLAYER_PARTID_NULL+1; i < PLAYER_PARTID_MAXID; i++)
	{
		IEntityPart* pEntityPart = GetEntityPart(i);
		IFNULL_CONTINUE(pEntityPart);
		nPower += pEntityPart->GetSelfPower(bRecalc);
	}
	nPower += CalcSuitPower();
	</pre>
	<ul>
		<li>
			等级战力
			<pre class="prettyprint">
	m_nLevelPower =
		( pBaseProp->dwBaseHP  * POWER_COEF_HP
		+ pBaseProp->dwBasePATK * POWER_COEF_PATK
		+ pBaseProp->dwBaseMATK * POWER_COEF_MATK
		+ pBaseProp->dwBasePDEF  * POWER_COEF_PDEF
		+ pBaseProp->dwBaseMDEF * POWER_COEF_MDEF
		+ pBaseProp->dwBaseCS * POWER_COEF_CRITICAL_STRIKE
		+ pBaseProp->dwBaseACS * POWER_COEF_ANTI_CRITICAL_STRIKE
		+ pBaseProp->dwBaseParry * POWER_COEF_ANTI_PARRY
		+ pBaseProp->dwAntiParry * POWER_COEF_ANTI_PARRY
		+ pBaseProp->dwDodge  * POWER_COEF_DODGE
		+ pBaseProp->dwHit * POWER_COEF_HIT
		+ pBaseProp->dwArmor * POWER_COEF_ARMOR
		+ pBaseProp->dwAntiArmor * POWER_COEF_ANTI_ARMOR
		+ pBaseProp->dwDamageReduction * POWER_COEF_DAMAGE_REDUCTION
		+ pBaseProp->dwDamageAdd * POWER_COEF_DAMAGE_ADD
		+ pBaseProp->dwMoveSpeed * POWER_COEF_SPD ) / POWER_COEF_RATE;
</pre>
		</li>
		<li>
			成就战力
			<pre class="prettyprint">
	m_nEmblemPower =
		(pAchieve->hp()  * POWER_COEF_HP
		+ pAchieve->attack() * POWER_COEF_ATK
		+ pAchieve->defense() * POWER_COEF_DEF
		+ pAchieve->physicsattack() * POWER_COEF_PATK
		+ pAchieve->magicattack() * POWER_COEF_MATK
		+ pAchieve->physicsdefense()  * POWER_COEF_PDEF
		+ pAchieve->magicdefense() * POWER_COEF_MDEF
		+ pAchieve->criticalstrike() * POWER_COEF_CRITICAL_STRIKE
		+ pAchieve->anticriticalstrike() * POWER_COEF_ANTI_CRITICAL_STRIKE
		+ pAchieve->parry() * POWER_COEF_ANTI_PARRY
		+ pAchieve->antiparry() * POWER_COEF_ANTI_PARRY
		+ pAchieve->dodge()  * POWER_COEF_DODGE
		+ pAchieve->hit() * POWER_COEF_HIT
		+ pAchieve->armor() * POWER_COEF_ARMOR
		+ pAchieve->antiarmor() * POWER_COEF_ANTI_ARMOR
		+ pAchieve->damagereduction() * POWER_COEF_DAMAGE_REDUCTION
		+ pAchieve->damageadd() * POWER_COEF_DAMAGE_ADD
		+ pAchieve->movespeed() * POWER_COEF_SPD
		+ pAchieve->attackdefense() * POWER_COEF_ATK_DEF) / POWER_COEF_RATE;
</pre>
		</li>
		<li>
			军衔战力
			<pre class="prettyprint">
	m_nMilitaryPower =
		(pMilitary->hp()  * POWER_COEF_HP
			+ pMilitary->attack() * POWER_COEF_ATK
			+ pMilitary->defense() * POWER_COEF_DEF
			+ pMilitary->physicsattack() * POWER_COEF_PATK
			+ pMilitary->magicattack() * POWER_COEF_MATK
			+ pMilitary->physicsdefense()  * POWER_COEF_PDEF
			+ pMilitary->magicdefense() * POWER_COEF_MDEF
			+ pMilitary->criticalstrike() * POWER_COEF_CRITICAL_STRIKE
			+ pMilitary->anticriticalstrike() * POWER_COEF_ANTI_CRITICAL_STRIKE
			+ pMilitary->parry() * POWER_COEF_ANTI_PARRY
			+ pMilitary->antiparry() * POWER_COEF_ANTI_PARRY
			+ pMilitary->dodge()  * POWER_COEF_DODGE
			+ pMilitary->hit() * POWER_COEF_HIT
			+ pMilitary->armor() * POWER_COEF_ARMOR
			+ pMilitary->antiarmor() * POWER_COEF_ANTI_ARMOR
			+ pMilitary->damagereduction() * POWER_COEF_DAMAGE_REDUCTION
			+ pMilitary->damageadd() * POWER_COEF_DAMAGE_ADD
			+ pMilitary->movespeed() * POWER_COEF_SPD
			+ pMilitary->attackdefense() * POWER_COEF_ATK_DEF) / POWER_COEF_RATE;
</pre>
		</li>
		<li>
			部件战力
			<ul>
				<li>背包部件 </li>
				<li>装备技能部件</li>
				<li>装备部件 </li>
				<li>神兵部件 </li>
				<li>逻辑部件 </li>
				<li>副本部件 </li>
				<li>技能部件 </li>
				<li>商店部件 </li>
				<li>帮会部件 </li>
				<li>时装部件 </li>
				<li>宝石部件 </li>
				<li>任务部件 </li>
				<li>仓库部件 </li>
				<li>新神兵部件 </li>
				<li>天赋部件 </li>
				<li>结婚部件 </li>
				<li>卡牌部件 </li>
				<li>生活技能部件</li>
				<li>坐骑部件 </li>
				<li>翅膀部件 </li>
				<li>buff部件 </li>
				<li>称号部件 </li>
				<li>特权卡部件 </li>
				<li>新翅膀部件 </li>
				<li>属性药部件 </li>
				<li>属性激活部件</li>
			</ul>
		</li>
		<li>套装战力</li>
	</ul>
	<hr />







	<h1 id="PacketPart">Packet部件</h1>
	<pre class="prettyprint">
		// 篮子ID
enum SKEPID
{
	SKEPID_UNKNOW = 0,
	SKEPID_EQUIP,							// 装备栏(流派1-剑)
	SKEPID_PACKET,							// 背包栏
	SKEPID_WEAPON,							// 神兵栏
	SKEPID_FASHION,							// 时装栏
	SKEPID_GEMPACK,                         // 宝石背包
	SKEPID_GEMSTORAGE,                      // 宝石仓库
	SKEPID_WAREHORSE,						// 仓库
	SKEPID_GODWEAPON,						// 新神兵栏(流派1-剑)
	SKEPID_GODWEAPONSPIRIT,					// 灵件(流派1-剑)
	SKEPID_MONSTERCARD,						// 怪物卡牌
	SKEPID_MOUNT,							// 坐骑
	SKEPID_MOUNTEQUIP,						// 坐骑装备
	SKEPID_WING,							// 仙器
	SKEPID_WINGEQUIP,						// 仙器器魂
	SKEPID_ACTIVITYPACK,					// 活动背包
	SKEPID_TASKPACKET,						// 任务背包栏
	SKEPID_NEWWING,							// 羽翼背包
	SKEPID_MOUNTEQUIPPACKET,				// 坐骑装备背包
	SKEPID_EQUIP2,							// 装备栏(流派2-笔)
	SKEPID_GODWEAPON2,						// 新神兵栏(流派2-笔)
	SKEPID_GODWEAPONSPIRIT2,				// 灵件(流派2-笔)
	SKEPID_WINGEQUIPEXTRA,					// 仙器装备
	SKEPID_WINGEQUIPPACKET,					// 仙器装备背包
	SKEPID_NEWWINGEQUIP,					// 羽翼装备
	SKEPID_NEWWINGEQUIPPACKET,				// 羽翼装备背包
	SKEPID_WINGEQUIP2,						// 仙器器魂(流派2-笔)
	SKEPID_MAXID,
};

		// 篮子权限
enum SKEP_ACCESS
{
	SKEP_ACCESS_ADD = 0x0001,				// 添加权限
	SKEP_ACCESS_UNITE = 0x0002,				// 合并权限
	SKEP_ACCESS_REMOVE = 0x0004,			// 移除权限
	SKEP_ACCESS_USE = 0x0008,				// 使用权限
	SKEP_ACCESS_SELL = 0x0010,				// 出售权限
};
	</pre>
	<h1>Logic部件</h1>
	<pre class="prettyprint">
enum LOGIC_DATA
{
	DATA_LAST_DAYRESET_TIME = 1,					// 最后每日清0时间(0)
	DATA_LAST_WEEKRESET_TIME = 2,					// 最后每周清0时间(0)
	DATA_LAST_MONTHRESET_TIME = 3,					// 最后每月清0时间(0)
	DATA_WORLD_CHAR_LAST_TIME = 4,					// 上一次在世界频道发言时间(0)
	DATA_TRUNK_TASK_CUR_SERIAL = 5,					// 主线任务已完成序号(1)
	DATA_GOLDHAND_USE_TIMES = 6,					// 今天使用点金手次数(1)
	DATA_WEEK_SIGNIN_BITS = 7,						// 每日签到保存的数据位集(1)
	DATA_ARENAGAME_TODAYTIMES = 8,					// 玩家今天可进入竞技场次数(1)
	DATA_ARENAGAME_BUYTIMES = 9,					// 玩家今天购买进入竞技场次数(1)
	DATA_ARENAGAME_TOPRANK = 10,					// 玩家竞技场中最高的排名(1)
	DATA_DIAMONDDRAW_JACKPOT = 11,					// 元宝抽奖奖池(1)
	DATA_TREASURESNATCH_THROW_COUNT = 12,			// 夺宝奇兵当前投色子的次数(1)
	DATA_TREASUREHOUSE_DATA = 13,					// 宝阁抽奖次数(地宝阁2|天宝阁1|仙宝阁0)(1)
	DATA_TEAM_FIRST_APPLY_OR_INVITE = 14,			// 好友邀请|帮会成员邀请|好友申请|帮会成员申请(组队设置：优先接收帮会或好友的玩家)(1)
	DATA_HOLIDAYMAKE_DAYCOUNT2 = 15,				// 节日制作活动每日次数(1)
	DATA_EAST_CITY_DAY_INFO = 16,					// 保留|生存挑战免费次数|玲珑宝塔免费次数|全民寻宝免费次数(1)
	DATA_EAST_CITY_PRIZE_FLAG = 17,					// 全民寻宝宝箱领取标志(1)
	DATA_EAST_CITY_CLICK_TIME = 18,					// 全民寻宝参与抽奖的时间(1)
	DATA_EAST_CITY_COST_TIME = 19,					// 全民寻宝付费抽奖的时间(1)
	DATA_CHIEF_FIRST_KILL_HAVEGET = 20,				// 首杀成就是否领取(1)
	DATA_CHIEF_FIRST_KILL_FLAG = 21,				// 首领首杀标志(1)
	DATA_FOLLOWNPC_USECOUNT = 22,					// 跟随功能使用加奖励buff次数
	DATA_ENERGY_BUYTIMES = 23,						// 今日购买体力次数(1)
	DATA_ENERGY_LASTFETCHTIME = 24,					// 上一次领取体力的时间(1)
	DATA_SOCIETY_ECTYPETOWER_CURSTAGE = 25,			// 帮会副本塔-当前关卡
	DATA_SOCIETY_ECTYPETOWER_HIGHSTAGE = 26,		// 帮会副本塔-历史最高关卡
	DATA_SOCIETY_ECTYPETOWER_DAYRESETTIMES = 27,	// 帮会副本塔-当日重置次数
	DATA_ACTIVITY_STACKCOUNT_1 = 28,				// 找回次数积累(前日积累次数|当前数值找回次数|当前资源找回次数)
	DATA_SOCIETY_ECTYPETOWER_TODAY_MAXSTAGE = 29,	// 帮会副本塔, 当日最高关卡
	DATA_SOCIETY_ECTYPETOWER_PRIZE = 30,			// 帮会副本塔奖励领取标记
	DATA_BRANCH_ROUND_DATASET = 31,					// 今日完成、购买任务轮数(1)
	DATA_MIDAS_TOUCH_USETIMES = 32,					// 钱庄次数(1)
	DATA_LOTTERY_MONEY_NEXTTIME = 33,				// 下一次免费金币抽奖时间(1)
	DATA_LOTTERY_MONEY_TODAYTIMES = 34,				// 免费金币抽奖进入使用次数(1)
	DATA_LOTTERY_DIAMOND_NEXTTIME = 35,				// 下一次免费钻石抽奖时间(1)
	DATA_LOTTERY_DIAMOND_FRISTTIME = 36,			// 首次钻石抽奖时间记录(1)
	DATA_INIT_ACTOR_EQUIP_TIME = 37,				// 初始化角色装备时间(0)
	DATA_ARENAGAME_ALLOW_TIME = 38,					// 玩家可挑战竞技场时间(1)
	DATA_CHIEFGAME_FIRST_PRIZE = 39,				// 首次成为任意章节霸主奖励(1)
	DATA_LOGIN_GETTIME = 40,						// 累计登陆奖励领取情况(可领取天数|已领取天数)(1)
	DATA_TRUNK_TASK_ACCEPT_SERIAL = 41,				// 主线任务已接受序号(1)
	DATA_SOLOGAME_WINSTREAK_PRIZE = 42,				// 1v1 胜利奖励领取标记
	DATA_REDBAG_LIMITTIMES = 43,					// 世界红包领取次数限制
	DATA_REDBAG_SOCIETY_LIMITTIMES = 44,			// 帮会红包领取次数限制
	DATA_SOCIETY_TRAIN_CONSUME = 45,				// 每天消耗帮贡数值
	DATA_DAY_CONSUME_DIAMOND = 46,					// 每天消耗元宝数值
	DATA_LOGIN_CONTINUE_DAYS = 47,					// 连续登录天数
	DATA_ECTYPE_RESETTIMES1 = 48,					// 副本今天已重置次数1
	DATA_ECTYPE_RESETTIMES2 = 49,					// 副本今天已重置次数2
	DATA_ECTYPE_TODAYENTERECTYPETIMES = 50,			// 当日进入副本次数
	DATA_ESCORTGAME_GOTPRIZEFLAG = 51,				// 押镖活动当日领取奖励标志
	DATA_EAST_CITY_DRAW_TIMES = 52,					// 全民寻宝抽奖累计次数(1)
	DATA_SMASHEGG_DATA1 = 53,						// 砸蛋数据(每天砸蛋次数+9(免费砸蛋次数)+(111111111累计次数的奖励是否已领(0-8)512))
	DATA_SMASHEGG_DATA2 = 54,						// 砸蛋数据(砸蛋中过的物品(0-3字节))
	DATA_SMASHEGG_DATA3 = 55,						// 砸蛋数据(砸蛋中过的物品(0-1字节))
	DATA_SMASHEGG_DATA4 = 56,						// 砸蛋数据(总的砸蛋次数+(11111111是否出过珍稀物品(7)+是否出过彩蛋(6)+金蛋彩蛋数据(0-5)(256)))
	DATA_SMASHEGG_DATA5 = 57,						// 砸蛋数据(砸蛋参与时间)
	DATA_NEWBIE_TARGETPRIZE_HAVEGET2 = 58,			// 新手目标奖励是否领取
	DATA_NEWBIE_TARGETPRIZE_HAVEGET1 = 59,			// 新手目标奖励是否领取
	DATA_TIMESHOPPING = 60,							// 限时特购礼包购买记录
	DATA_SPECIAL_ACTION_RECORD = 61,				// 特殊行为记录
	DATA_BABEL_ALLOW_TIME = 62,						// 刷塔重置时间(1)
	DATA_VIP_GET_PERDAY_GIFT = 63,					// 每日VIP礼包(0vip礼包+1军衔礼包+2爱情宝盒+3周签到+4特权免费礼包+567仙宝阁+8910特权到期发邮件+特权礼包(17位开始))
	DATA_SCORECHALLENGE_TIME = 64,					// 积分挑战次数(1)
	DATA_ACTIVITY_GIFT_GET = 65,					// 活动礼包是否领取(媒体礼包|新手礼包)(1)
	DATA_SAVEBIT_NORESET = 66,						// 按位存不清零的数据(012特权到期发邮件)
	DATA_SEVEN_COLOR_EGGS_RECHARGE_VALUE = 67,		// 七彩扭蛋活动期间累计充值元宝(1)
	DATA_SEVEN_COLOR_EGGS_CLICK_TIME = 68,			// 七彩扭蛋参与扭蛋时间
	DATA_SEVEN_COLOR_EGGS_DRAW_TIMES = 69,			// 七彩扭蛋累计扭蛋次数
	DATA_COMPENSATE_GIFT = 70,						// 补偿礼包是否领取(0)
	DATA_FIRSTCHARGE_TIME = 71,						// 首冲时间(1)
	DATA_FIRSTCHARGE_DATA = 72,						// 首充礼包是否领取(1)
	DATA_RECHARGECARD_VALIDTIME = 73,				// 充值卡的有效时间(0)
	DATA_RECHARGECARD_CARDID = 74,					// 充值卡ID(月、季、终身卡)(0)
	DATA_RECHARGECARD_GIFTGOT = 75,					// 充值卡赠送礼包是否领取(1)
	DATA_RECHARGECARD_LIMITTIME = 76,				// 购买过的充值卡标记(1)
	DATA_TEAMECTYPE_TIMES1 = 77,					// 组队副本完成次数(上午)(1)
	DATA_TEAMECTYPE_TIMES2 = 78,					// 组队副本完成次数(下午)(1)
	DATA_GOLDBOSS_ENTERTIME = 79,					// 主动进入黄金BOSS时间(1)
	DATA_PRIZETIME_CANGET = 80,						// 限时礼包是否可领取(1)
	DATA_PRIZETIME_HAVEGET = 81,					// 限时礼包是否已领取(1)
	DATA_LAST_RECHAREGE_TIME = 82,					// 最近的一次充值时间(1)
	DATA_CONTINUE_RECHARGE_DAYS = 83,				// 连续充值天数(1)
	DATA_CONTINUE_RECHARGE_PRIZES = 84,				// 连续充值天数奖励领取标记(1)
	DATA_CONTINUE_RECHARGE_LASTTIME = 85,			// 连续充值上一次参加活动的开启时间(1)
	DATA_DAYRECHARGE_VALUE = 86,					// 当日充值金额
	DATA_RECHARGEDRAW_COUNT = 87,					// 充值抽奖次数
	DATA_COUNTRYWORSHIP_TIMES = 88,					// 国王膜拜
	DATA_HOLIDAYMAKE_DAYCOUNT1 = 89,				// 节日制作活动每日次数(1)
	DATA_OFFLINETIME = 90,							// 离线时长
	DATA_RECHARGEREDGIFT_GOODS9 = 91,				// 充值赠送的物品9(1)
	DATA_FRIENDREDGIFT_TIMES = 92,					// 领取好友红包的次数(0)
	DATA_GUIDELOG_GUIDEID = 93,						// 引导记录引导ID(1)
	DATA_GUIDELOG_STEPID = 94,						// 引导记录步骤ID(1)
	DATA_SOCIETY_DEVELOPMENT_PRIZE = 95,			// 帮会建设可领奖励， 根据位判断
	DATA_REDBAG_SOCIETY_TOTALTIMES = 96,			// 领取帮派红包的总次数
	DATA_GIFTFLOWER_TOTALTIMES = 97,				// 送花的总次数
	DATA_ENTERWAR_TOTALTIMES = 98,					// 参与战场次数
	DATA_FRIENDBLESS_GAVEPRIZECOUNT = 99,			// 当日发送好友祝福奖励次数
	DATA_FRIENDBLESS_RECEIVEPRIZECOUNT = 100,		// 当日收到好友祝福奖励次数
	DATA_STACKCOUNT_1 = 101,						// 粮草护送|军情刺探|火烧连营|每日历练积累次数
	DATA_STACKCOUNT_2 = 102,						// 帮会采集|国家战备|金钱副本|每日跑环积累次数
	DATA_STACKCOUNT_3 = 103,						// 坐骑副本|升星副本|强化副本|仙器副本积累次数
	DATA_STACKCOUNT_4 = 104,						// 神兵副本|羽翼副本|巨鹿之战|城阳之战积累次数
	DATA_STACKCOUNT_5 = 105,						// 鸿门宴|经验副本积累次数
	DATA_ESCORT_DAY_ROBTIMES = 106,					// 当日劫镖次数
	DATA_COUNTRY_WILDFIGHT_PRIZE_TIMES = 107,		// 中立区杀人奖励次数
	DATA_ECTYPETOWER_CURSTAGE = 108,				// 副本塔-当前关卡
	DATA_ECTYPETOWER_HIGHSTAGE = 109,				// 副本塔-最高关卡
	DATA_ECTYPETOWER_DAYRESETTIMES = 110,			// 副本塔-当日重置次数
	DATA_ECTYPETOWER_HIGHSTAGETIME = 111,			// 副本塔-最高关卡到达时间
	DATA_LEVELSTEPECTYPE_CURSTEP = 112,				// 当前转生副本阶段
	DATA_LEVELSTEPECTYPE_SELECTSTEP = 113,			// 当前选择转生形象(废弃)
	DATA_LOGINPRIZE_GOTFLAG = 114,					// 登录礼包领取标记
	DATA_FUND_ISBUY = 115,							// 基金是否购买标记
	DATA_FUND_GETPRIZE = 116,						// 基金奖励领取标记

	DATA_NEWSERVERRANKPRIZE_GETFLAG = 117,			// 新服排名奖励领取标记
	DATA_ACTIVITY_JOINFLAG = 118,					// 当日参与活动标记
	DATA_LASTTIME_LUCKY_DRAW = 119,					// 上一次欢乐抽奖的时间
	DATA_LUCKY_DRAW_COUNT = 120,					// 欢乐抽奖次数
	DATA_LUCKY_DRAW_COST_DIAMOND = 121,				// 欢乐抽奖期间花费的元宝
	DATA_ACTIVITYCOUNT_VALUE = 122,					// 今日活跃度
	DATA_ACTIVITYCOUNT_PRIZEGETFLAG = 123,			// 活跃度奖励领取标记
	DATA_VIPLEVEL_PRIZE = 124,						// VIP等级礼包领取标记
	DATA_DOWNLOADPACK_PRIZEGETFLAG = 125,			// 下载热更包礼包领取标记
	DATA_BANK_STAR = 126,							// 钱庄星级
	DATA_LINGLONG_PAGODA_UP_FLAG = 127,				// 玲珑宝塔最高次数跳转标志（从0~31来索引）
	DATA_LINGLONG_PAGODA_TIME = 128,				// 玲珑宝塔玩家参与抽奖时间
	DATA_LINGLONG_PAGODA_STATE = 129,				// 玲珑宝塔进度记录（保留|CSV表格索引ID|当前哪个格子|当前第几层）(1)
	DATA_LINGLONG_PAGODA_DRAW_TIMES = 130,			// 玲珑宝塔累计抽奖次数(1)
	DATA_TITLE_SLOT_NUM = 131,						// 称号位数量
	DATA_ARENAGAME_GETPRIZEFLAG = 132,				// 竞技场每日领取奖励
	DATA_ACTIVITY_VIP_GIFT_GET = 133,				// VIP礼包是否领取(1)改成每日特惠
	DATA_ACTIVITY_DAY_BUYRECORD = 134,				// 活动日购买记录(升星日|强化日|坐骑日|仙器日|神兵日|洗练日|羽翼日|猎魂日)(1)
	DATA_ESCORTGAME_COUNTERTIMES = 135,				// 押镖反击次数(1)
	DATA_ESCORTGAME_REFRESHTIMES = 136,				// 押镖刷新次数(1)
	DATA_FIRSTRECHARGE_NUM = 137,					// 首充多少钱(1)
	DATA_ANYRECHARGE_GET = 138,						// 任意充值礼包领取(1)
	DATA_EXPWELFARE_GET = 139,						// 今天已经获得的经验福利
	DATA_EXPWELFARE_NOGET = 140,					// 前一天剩余未得经验值
	DATA_ACTIVITY_POWERRANK_GIFT_GET = 141,			// 新服实战排行礼包是否领取(1)
	DATA_ACTIVITY_WEEKEND_GIFT = 142,				// 双休礼包是否领取(1)
	DATA_COUNTRY_LASTBETRAYTIME = 143,				// 上次叛国时间
	DATA_COUNTRYWELFARE_GET = 144,					// 国家福利(1)
	DATA_DAYGOTTARGETPRIZE_FLAG = 145,				// 当日是否获得过特定奖励标志
	DATA_STORE1_LASTRESET = 146,					// 商店1上次重置刷新次数时间(1)
	DATA_STORE2_LASTRESET = 147,					// 商店2上次重置刷新次数时间(1)
	DATA_STORE3_LASTRESET = 148,					// 商店3上次重置刷新次数时间(1)
	DATA_STORE4_LASTRESET = 149,					// 商店4上次重置刷新次数时间(1)
	DATA_STORE5_LASTRESET = 150,					// 商店5上次重置刷新次数时间(1)
	DATA_STORE6_LASTRESET = 151,					// 商店6上次重置刷新次数时间(1)
	DATA_STORE7_LASTRESET = 152,					// 商店7上次重置刷新次数时间(1)
	DATA_STORE8_LASTRESET = 153,					// 商店8上次重置刷新次数时间(1)
	DATA_FORBIDCHAT_TIMES = 154,					// 国王的禁言次数(放这里了，懒得在国家加了)
	DATA_BIGRECHARGE_DATA = 155,					// 单笔大充值数据(1)
	DATA_PRIZEDAYRECHARGE_CANGET = 156,				// 每日累计充值是否可领取(1)
	DATA_PRIZEDAYRECHARGE = 157,                    // 每日累计充值金额(1)
	DATA_PRIZE_TOTAL_RECHARGE = 158,				// 累计充值活动时的累计充值金额(1)
	DATA_PRIZE_TOTAL_RECHARGE_TIME = 159,			// 记录充值时累计充值活动的开始时间(1)
	DATA_NEWBIE_TARGETPRIZE_HAVEGET3 = 160,			// 新手目标奖励是否领取(1)

	DATA_COSTPRIZE_CANGET = 161,					// 累计消费奖励可领(1)
	DATA_COSTPRIZE_HADGOT = 162,					// 累计消费奖励已领(1)
	DATA_DIGMINE_LASTTIME = 163,					// 上一次挖宝的时间(1)
	DATA_DIGMINE_TIMES = 164,						// 挖宝次数(1)
	DATA_LOGIN_TIMES = 165,                         //上一次登陆时间(1)
	DATA_ONLINEPRIZE_CANGET = 166,                    //在线时长奖励是否可领取(1)
	DATA_LOGIN_TOTALTIME = 167,                    //累计在线时长(1)

	DATA_HOLIDAY_DRAW_FREE_TIMES = 168,             //节日抽奖免费次数(1)
	DATA_WILDBATTLE_TIMES = 169,					//楚汉战场次数(当日进入地宫次数|当日总次数|当日可用次数)(1)
	DATA_WILDBATTLE_KILLNUM = 170,					//楚汉战场总击杀数(1)
	DATA_WILDBATTLE_CONTINUEKILL = 171,				//楚汉战场最高连斩数(1)
	DATA_WILDBATTLE_KILLNUM_PERDAY = 172,			//楚汉战场每日总击杀数(1)
	DATA_WILDBATTLE_CONTKILL_PERDAY = 173,			//楚汉战场每日最高连斩数(1)
	DATA_WILDBATTLE_CURTIME = 174,					//楚汉战场当前数据时间戳(0)
	DATA_ACTIVITY_GIFT_GET1 = 175,					//活动礼包是否领取(媒体礼包|新手礼包)(1)DATA_ACTIVITY_GIFT_GET不够用的追加
	DATA_COSTDIAMOND_TIME = 177,                	//累计消费时间(1)

	DATA_PACKET_VALID_SIZE = 178,					//背包可用格子
	DATA_WAREHORSE_VALID_SIZE = 179,				//仓库可用格子

	DATA_TEAM_INVITE_MIN_LEVEL_LIMIT = 180,				// 自动接受邀请最小等级限制
	DATA_TEAM_INVITE_MAX_LEVEL_LIMIT = 181,				// 自动接受邀请最大等级限制
	DATA_TEAM_APPLY_MIN_LEVEL_LIMIT = 182,				// 自动接受申请最小等级限制
	DATA_TEAM_APPLY_MAX_LEVEL_LIMIT = 183,				// 自动接受申请最大等级限制

	DATA_FRIEND_APPLY_LIMIT = 184,						// 好友申请设置

	DATA_AUTOADDHP_PERCENT = 185,						// 血量低于%x自动回血(1)
	DATA_HANDADDHP_COSTID = 186,					//手动回血消耗药品ID(1)
	DATA_AUTOADDHP_COSTID = 187,						// 自动回血消耗药品ID(1)
	DATA_LIFESKILL_ACTIVEFLAG = 188,					// 生活技能激活标记 按位读(1)
	DATA_SPACIALSKILL_USEDTIMES = 189,					// 装备特技今日使用次数(1)

	DATA_DAY_RELIVE_TIMES = 190,					// 今日复活次数(1)
	DATA_COUNTRY_CHAR_LAST_TIME = 191,				//上一次在国家频道发言时间(0)
	DATA_GUIDELOG_EVENTID = 192,						// 引导记录事件ID(1)
	DATA_GUIDEOPEN_ID = 193,							//导航按钮开启ID
	DATA_TEAM_APPLY_MIN_POWER_LIMIT = 194,				// 自动接受申请最小战力限制
	DATA_TEAM_INVITE_MIN_POWER_LIMIT = 195,				// 自动接受邀请最小战力限制
	DATA_SOCIETR_ACTIVITYCOLLECT = 196,				//帮会采集活动次数

	//添加成就逻辑字段
	DATA_LOGIN_TOTALDAYS = 197,						//玩家累计登录天数
	DATA_MONEY_TOTALNUM = 198,							//财富最大值
	DATA_PARY_TOTALNUM = 199,							//祈福累计数
	DATA_TRAIN_TOTALNUM = 200,							//帮贡最大数
	DATA_RINGTASK_TOTALNUM = 201,						//跑环任务累计完成数
	DATA_LOGINCHIEVE_HAVEGET = 202,						//登录成就是否领取
	DATA_LEVELACHIEVE_HAVEGET = 203,					//等级成就是否领取
	DATA_POWERCHIEVE_HAVEGET = 204,						//战力成就是否领取
	DATA_EQUIPMENT_HAVEGET = 205,						//装备强化等级成就是否领取
	DATA_SOCTETY_HAVEGET = 206,							//帮会成就是否领取
	DATA_DVINEEQUIPMENT_HAVEGET = 207,					//神兵成就是否领取
	DATA_HORSE_HAVEGET = 208,							//坐骑成就是否领取
	DATA_WING_HAVEGET = 209,							//挂件成就是否领取
	DATA_EQUIPMENTSTAR_HAVEGET = 210,					//装备升星成就是否领取
	DATA_MULTIPLE_RECHARGE_SUM = 211,					//多重充值金额
	DATA_MULTIPLE_RECHARGE_GET = 212,					//多重充值领取次数
	DATA_TREASURESNATCH_GRID_INFO = 213,				//扔色子的次数|特殊宝箱获取到的数量|特殊宝箱随机的起始位置(1)
	DATA_TREASURESNATCH_GRID_FLAG = 214,				//格子里的奖励是否被获取过了(1)
	DATA_DIAMONDDRAW_COUNT = 215,						//元宝抽奖次数(1)
	DATA_PRIZELOOP_CAMPWELFARE_GOTCOUNT = 216,			//阵营每日奖励是否领取
	DATA_GEMCREATE_FREECOUNT = 217,			    		//猎魂今日已经免费使用次数|洗练、精炼|帮会通天塔今日已重置次数
	DATA_THREEVSTHREE_WIN_PRIZE = 218,					// 3v3宝箱奖励领取标记
	DATA_LAST_TIME_PLAY_SOLO = 219,						// 上一次参加1v1的活动时间
	DATA_LAST_TIME_PLAY_THREEVSTHREE = 220,				// 上一次参加3v3的活动时间
	DATA_TEAMSYSTEMREDBAG_TIMES = 221,					// 组队系统红包领取次数
	DATA_SOCIETYSYSTEMREDBAG_TIMES = 222,				// 帮会系统红包领取次数
	DATA_TREASUREHUNT_DATA = 223,						// 提示宝箱序号+行列+体力数+重置次数(1)
	DATA_TREASUREHUNT_BOX = 224,						// 寻宝活动的宝箱位置(1)
	DATA_TREASUREHUNT_BOMB = 225,						// 寻宝活动的地雷位置(1)
	DATA_TREASUREHUNT_WALKPATH = 226,					// 寻宝活动的走过路径(1)
	DATA_TREASURESNATCH_DATA = 227,						// 上次色子点数|当前位置|当前免费次数|最多可重置次数(1)
	DATA_CAN_CUSTOMIZETITLE = 228,						// 是否能定制称号(1)
	DATA_LOGIN_ACTIVITY_DATA = 229,						// 登录有礼活动数据(登录天数+是否领取奖励)(1)
	DATA_LOGIN_ACTIVITY_TIME = 230,						// 记录登录有礼活动时间
	DATA_RECHARGE_RETURN_DATA = 231,					// 充值返现活动是否领取(高16存是否可领，低16位存是否领取)(1)
	DATA_RECHARGE_RETURN_TIME = 232,					// 记录充值返现活动时间
	DATA_ACTIVITY_VIP_GIFT_GET1 = 233,					// 每日特惠(1)
	DATA_LAST_COSTDIAMOND_TIME = 234,                	// 最近一次消费元宝时间(0)
	DATA_PERDAY_COSTDIAMOND_GET = 235,					// 每日累计消费是否已领取(1)
	DATA_PERDAY_COSTDIAMOND_NUM = 236,					// 每日累计消费元宝数量(1)
	DATA_LOGIC_SOCIETY_ALCOHOL_TIMES = 237,				// 喝酒次数
	DATA_PRIVILEGECARD_TIME1 = 238,						// 特权卡(贵族)有效期
	DATA_PRIVILEGECARD_TIME2 = 239,						// 特权卡(王者)有效期
	DATA_PRIVILEGECARD_TIME3 = 240,						// 特权卡(至尊)有效期
	DATA_SEVENDAYS_INVEST_GET = 241,					// 七日投资是否领取(1)
	DATA_SEVENDAYS_INVEST_TIME = 242,					// 七日投资时间_绑定元宝(1)
	DATA_TURNTABLE_USETIMES = 243,						// (全民转盘免费使用次数:index 1|全民转盘购买次数:index 2)
	DATA_AURA_ACTIVE_WEAPON_STARS1 = 244,				// 灵气激活武器的星星
	DATA_AURA_ACTIVE_WEAPON_STARS2 = 245,				// 灵气激活武器的星星
	DATA_HOLIDAY_LOGIN_DATA = 246,						// 节日登录有礼活动数据(登录天数+是否领取奖励)(1)
	DATA_HOLIDAY_LOGIN_TIME = 247,						// 记录节日登录有礼活动时间
	DATA_AURA_ACTIVE_WEAPON_STARS3 = 248,				// 灵气激活武器的星星
	DATA_FESTIVAL_LIMIT_BUY = 249,						// 节日特购保存
	DATA_FESTIVAL_LIMIT_BUY_JOINTIME = 250,				// 节日特购参加时间
	DATA_ALCHEMY_SPEEDUP_TIMES = 251,					// 炼丹帮助次数（普通帮助次数|元宝帮助次数|每日炼丹次数）
	DATA_TREASUREHUNT_STEP = 252,						// 寻宝活动的历史步数(1)
	DATA_TREASUREHUNT_INFO = 253,						// 获取到的宝箱数量|当前游戏步数(1)
	DATA_SEVENDAY_BUYRECORD = 254,						// 七日目标购买记录
	DATA_RANK_OTHER_DATA = 255,							// 排行榜的其他数据(通天塔下线时的排名+竞技场下线时的排名)
	DATA_SUPPERZZLE_ITEMID1 = 256,						// 对对碰第一排物品对应表ID(字节1-4)
	DATA_SUPPERZZLE_ITEMID2 = 257,						// 对对碰第二排物品对应表ID(字节5-8)
	DATA_SUPPERZZLE_ITEMID3 = 258,						// 对对碰第三排物品对应表ID(字节9-12)
	DATA_SUPPERZZLE_ITEMID4 = 259,						// 对对碰第四排物品对应表ID(字节13-16)
	DATA_SUPPERZZLE_GETSIGN = 260,						// 对对碰操作记录(翻过牌记录0-15位 + 是否领取配对奖励16位开始)
	DATA_SUPPERZZLE_JOINTIME = 261,						// 对对碰参与时间
	DATA_SUPPERZZLE_TIMES = 262,						// 对对碰次数数据(配对次数/1000000 + 已翻牌次数%1000000)
	DATA_SUPPERZZLE_RECHARGE = 263,						// 对对碰期间充值金额
	DATA_RECHARGEBUY_ACTVTIME1 = 264,					// 充值直销活动1开启时间
	DATA_RECHARGEBUY_ACTVTIME2 = 265,					// 充值直销活动2开启时间
	DATA_RECHARGEBUY_ACTVTIME3 = 266,					// 充值直销活动3开启时间
	DATA_RECHARGEBUY_ACTVCOUNT1 = 267,					// 充值直销活动购买次数1(索引0-3)
	DATA_RECHARGEBUY_ACTVCOUNT2 = 268,					// 充值直销活动购买次数2(索引0-3)
	DATA_RECHARGEBUY_ACTVCOUNT3 = 269,					// 充值直销活动购买次数3(索引0-3)
	DATA_RECHARGEBUY_ACTVCOUNT4 = 270,					// 充值直销活动购买次数4(索引0-3)
	DATA_LUCKYFLOP_ITEMID1 = 271,						// 幸运翻牌随机到的6档物品(字节1-4)
	DATA_LUCKYFLOP_ITEMID2 = 272,						// 幸运翻牌随机到的6档物品(字节5-6)
	DATA_LUCKYFLOP_RECORD = 273,						// 翻过的牌面记录(000000)
	DATA_LUCKYFLOP_TIMES = 274,							// 是否领取次数奖励(000000预留6个)+总翻牌次数(/1000000)--每日刷新
	DATA_LUCKYFLOP_JOINTIME = 275,						// 幸运翻牌参与时间
	DATA_LUCKYFLOP_REFRESHTIME = 276,					// 幸运翻牌刷新时间
	DATA_LUCKYFLOP_TOTALNUM = 277,						// 幸运翻牌总翻牌次数(是否中过稀有物品(/1000000000) + 总次数(%1000000000))
	DATA_SEVENDAYS_INVEST_GET1 = 278,					// 七日投资是否领取(1)
	DATA_SEVENDAYS_INVEST_TIME1 = 279,					// 七日投资时间_坐骑(1)
	DATA_SEVENDAYS_INVEST_TIME2 = 280,					// 七日投资时间_仙器(1)
	DATA_SEVENDAYS_INVEST_TIME3 = 281,					// 七日投资时间_羽翼(1)
	DATA_SEVENDAYS_INVEST_TIME4 = 282,					// 七日投资时间_神兵(1)
	DATA_SEVENDAYS_INVEST_TIME5 = 283,					// 七日投资时间_升星(1)
	DATA_SEVENDAYS_INVEST_TIME6 = 284,					// 七日投资时间_强化(1)
	DATA_GENRE_COOLINGTIME = 285,						// 流派切换的冷却时间(记结束时间)

	// 超出这个值必须修改数据库接口(256+128)
	DATA_LOGICDATA_MAXID = 384,
};
</pre>
	<hr />































































































































	<h1>流派</h1>
	<pre class="prettyprint">
enum GENRE
{
	GENRE_NULL = 0,
	GENRE_SWORD,    // 流派-剑
	GENRE_PEN,      // 流派-笔
	GENRE_MAX,
};
</pre>
	<hr />







	<h1>角色数据的加载</h1>
	<p>三部分：角色数据、物品、任务</p>
	<pre class="prettyprint">
DBINPUT_LOAD_ACTOR_COMMAND dbInputCommand;
dbInputCommand.dwActorID = m_dwActorID;
if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_COMMAND, (LPCSTR)&dbInputCommand, sizeof(dbInputCommand)))
{
	_error("CTerminalStateLogin::OnEnter 请求角色常规数据失败，dwActorID=%d", m_dwActorID);
	return false;
}
DBINPUT_LOAD_ACTOR_GOODS dbInputGoods;	
dbInputGoods.dwActorID = m_dwActorID;
if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_GOODS, (LPCSTR)&dbInputGoods, sizeof(dbInputGoods)))
{
	_error("CTerminalStateLogin::OnEnter 请求角色物品数据失败，dwActorID=%d", m_dwActorID);
	return false;
}
DBINPUT_LOAD_ACTOR_TASK dbInputTask;	
dbInputTask.dwActorID = m_dwActorID;
if (!CDBSinkSingleton::Instance().ExecuteSP(m_dwActorID, SPID_LOAD_ACTOR_TASK, (LPCSTR)&dbInputTask, sizeof(dbInputTask)))
{
	_error("CTerminalStateLogin::OnEnter 请求角色任务数据失败，dwActorID=%d", m_dwActorID);
	return false;
}
</pre>
	<h1>篮子</h1>
	<p>角色可以拥有这么多篮子</p>
	<pre class="prettyprint">
enum SKEPID
{
	SKEPID_UNKNOW = 0,
	SKEPID_EQUIP,							// 装备栏(流派1-剑)
	SKEPID_PACKET,							// 背包栏
	SKEPID_WEAPON,							// 神兵栏
	SKEPID_FASHION,							// 时装栏
	SKEPID_GEMPACK,                         // 宝石背包
	SKEPID_GEMSTORAGE,                      // 宝石仓库
	SKEPID_WAREHORSE,						// 仓库
	SKEPID_GODWEAPON,						// 新神兵栏(流派1-剑)
	SKEPID_GODWEAPONSPIRIT,					// 灵件(流派1-剑)
	SKEPID_MONSTERCARD,						// 怪物卡牌
	SKEPID_MOUNT,							// 坐骑
	SKEPID_MOUNTEQUIP,						// 坐骑装备
	SKEPID_WING,							// 仙器
	SKEPID_WINGEQUIP,						// 仙器器魂
	SKEPID_ACTIVITYPACK,					// 活动背包
	SKEPID_TASKPACKET,						// 任务背包栏
	SKEPID_NEWWING,							// 羽翼背包
	SKEPID_MOUNTEQUIPPACKET,				// 坐骑装备背包
	SKEPID_EQUIP2,							// 装备栏(流派2-笔)
	SKEPID_GODWEAPON2,						// 新神兵栏(流派2-笔)
	SKEPID_GODWEAPONSPIRIT2,				// 灵件(流派2-笔)
	SKEPID_WINGEQUIPEXTRA,					// 仙器装备
	SKEPID_WINGEQUIPPACKET,					// 仙器装备背包
	SKEPID_NEWWINGEQUIP,					// 羽翼装备
	SKEPID_NEWWINGEQUIPPACKET,				// 羽翼装备背包
	SKEPID_WINGEQUIP2,						// 仙器器魂(流派2-笔)
	SKEPID_MAXID,
};
</pre>
	<h1>技能</h1>
	<h2>技能基础配置</h2>
	<p>Skill.csv</p>
	<ul>
		<li>ID 技能id</li>
		<li>Hit 命中</li>
		<li>AttackPoint 攻击点数</li>
		<li>AttackPercentage 攻击百分比</li>
		<li>IgnoreDefensePoint 忽视防御</li>
		<li>IgnoreDefensePercentage 忽视防御百分比</li>
		<li>DamagePoint 附加伤害</li>
		<li>DamagePercentage 附加伤害百分比</li>
		<li>CriticalPoint 暴击</li>
		<li>Pierce 穿透</li>
		<li>PhysicsOrMagic 1物攻 2法攻</li>
	</ul>
	<hr />







	<h2>技能等级配置</h2>
	<p>SkillEffect.csv</p>
	<ul>
		<li>Level 等级</li>
		<li>AttackPoint 攻击点数</li>
		<li>AttackPercentage 攻击百分比</li>
		<li>IgnoreDefensePoint 忽视防御</li>
		<li>IgnoreDefensePercentage 忽视防御百分比</li>
		<li>DamagePoint 附加伤害</li>
		<li>DamagePercentage 附加伤害百分比</li>
		<li>BreakPoint 破甲</li>
		<li>CriticalPoint 暴击</li>
		<li>Hit 命中</li>
		<li>Pierce 穿透</li>
	</ul>
	<hr />







	<h1>伤害公式</h1>
	<p>假设a打b</p>
	\[\text{let} \quad csMillionRev = 0.0001\]

	<p>命中</p>
	\[
	\text{let} \quad fHit = a.Hit - b.Dodge + Skill.Hit \times SkillEffect.Hit \times csMillionRev\\
	fHit=
	\begin{cases}
	fHit \times 0.1 + 95, & \quad fHit \gt -100\\
	fHit \times 0.06 + 85, & \quad fHit \gt -300\\
	fHit \times 0.01 + 73,& \quad \text{others}\\
	\end{cases}
	\\
	fHit = \max(fHit, 60)\\
	fHit = \min(fHit, 100)\\
	\]

	<p>闪避</p>
	\[\text{if} \quad random(0, 100) > fHit, \text{闪避成功，无伤害}\]

	<p>技能攻击</p>
	\[
	\text{let} \quad a1=
	\begin{cases}
	a.PhysicsAttack, & \quad Skill.PhysicsOrMagic == Physics\\
	a.MagicAttack, & \quad \text{others}
	\end{cases}\\

	\text{let} \quad A = (a1 + Skill.AttackPoint \times SkillEffect.AttackPoint \times csMillionRev) \times (1 +
	Skill.AttackPercentage \times SkillEffect.AttackPercentage \times csMillionRev^2)\\
	\]

	<p>目标防御</p>
	\[
	\text{let} \quad b1=
	\begin{cases}
	b.PhysicsDefense, & \quad Skill.PhysicsOrMagic == Physics\\
	b.MagicDefense, & \quad \text{others}
	\end{cases}\\

	\text{let} \quad B = b1 \times (1 - Skill.IgnoreDefensePercentage \times SkillEffect.IgnoreDefensePercentage \times
	csMillionRev)
	- Skill.IgnoreDefensePoint \times SkillEffect.IgnoreDefensePoint \times csMillionRev\\

	B = \max(0, B)
	\]

	<p>附加伤害百分比</p>
	\[
	\text{let} \quad y5=
	\begin{cases}
	\frac{Skill.DamagePercentage \times SkillEffect.DamagePercentage}{csMillionRev^2} , & \quad Skill.DamagePercentage
	\gt 0\\
	(Skill.DamagePercentage + SkillEffect.DamagePercentage) \times csMillionRev, & \quad \text{others}
	\end{cases}\\

	\text{let} \quad C = y5 + a.DamageAdd \times csMillionRev + y5\\

	C = \max(0, C)
	\]

	<p>附加伤害点数</p>
	\[
	\text{let} \quad D = Skill.DamagePoint \times SkillEffect.DamagePoint \times csMillionRev\\
	\]

	<p>暴击</p>
	\[
	\text{let} \quad S = a.CriticalStrike + Skill.CriticalPoint \times SkillEffect.CriticalPoint \times csMillionRev
	- b.CriticalStrike\\
	\text{let} \quad SRate=
	\begin{cases}
	0, & \quad S \le 0\\
	S \times 0.001 + 0.06, & \quad S \le 100\\
	(S - 100) \times 0.0004 + 0.16, & \quad S \le 300\\
	(S - 300) \times 0.0002 + 0.24, & \quad S \le 1000\\
	\min(0.5, (S - 1000) \times 0.0001 + 0.38, & \quad \text{others}
	\end{cases}\\
	\]

	<p>格挡</p>
	\[
	\text{let} \quad P = b.Parry - Skill.Pierce \times SkillEffect.Pierce \times csMillionRev - a.AntiParry\\
	\text{let} \quad PRate=
	\begin{cases}
	\max(0, P \times 0.0003 + 0.06), & \quad P \le 0\\
	P \times 0.0012 + 0.06, & \quad P \le 100\\
	(P - 100) \times 0.0004 + 0.18, & \quad P \le 300\\
	(P - 300) \times 0.0002 + 0.26, & \quad P \le 1000\\
	\min(0.5, (P - 1000) \times 0.0001 + 0.4, & \quad \text{others}
	\end{cases}\\
	\]

	<p>伤害减免</p>
	\[
	\text{let} \quad E = C - b.DamageReduction \times csMillionRev - \min(1.5, P)\\
	E = max(0, E)
	\]

	<p>暴击伤害加成</p>
	\[
	\\
	\text{let} \quad G=1 + \max(S,0) \times 0.0002\\
	G=\min(G, 2)
	\\

	\text{let} \quad K=
	\begin{cases}
	A \times 1.5 - B, & \quad A \ge B\\
	\frac{A^2}{A \times 1.7 + B \times 0.3},& \quad \text{others}\\
	\end{cases}
	\\

	K = \max(0, K)
	\\
	\\
	\text{let} \quad F=
	\begin{cases}
	K, & \quad K \lt 2000\\
	2000 + (K - 2000) \times 0.5,& \quad K \lt 15000\\
	8500 + (K - 15000) \times 0.45,& \quad K \lt 50000\\
	26500 + (K - 50000) \times 0.35,& \quad K \lt 10000\\
	44000 + (K - 100000) \times 0.2,& \quad \text{others}\\
	\end{cases}
	\\
	\text{let} \quad H = \max((F+D) \times E \times G, 1) + \lfloor A \times 0.005 \times E \rfloor
	\\
	\text{let} \quad nDamAdd2 =
	\begin{cases}
	a.PlayerDamangeAdd, & \quad \text{a is player}\\
	a.MonsterDamangeAdd,& \quad \text{others}
	\end{cases}
	\\
	\text{if} \quad nDamAdd2 \gt 0, H = H \times (1 + nDamAdd2 \times csMillionRev)
	\\
	H=\min(H, 10000000)
	\]

	<p>暴击、格挡，随机</p>
	<p>\(\text{if} \quad random(0,1) \lt srate + prate\)</p>
	\[
	H=
	\begin{cases}
	H \times 1.5, \quad \text{if} \quad random(0,srate + prate) \lt srate\\
	H \times 0.5, \quad \text{others}
	\end{cases}
	\]

	<p>如果B是玩家，A也是玩家，分段伤害</p>
	\[H=
	\begin{cases}
	H \times 0.9 + 10, & \quad \frac{H}{b.MaxHP} \lt 0.12\\
	b.MaxHP \times 0.08, & \quad \frac{H}{b.MaxHP} \lt 0.15\\
	b.MaxHP \times 0.1, & \quad \frac{H}{b.MaxHP} \lt 0.3\\
	b.MaxHP \times 0.17, & \quad \frac{H}{b.MaxHP} \lt 1\\
	b.MaxHP \times 0.4, & \quad \frac{H}{b.MaxHP} \lt 3\\
	b.MaxHP \times 0.9, & \quad \text{others}
	\end{cases}
	\]
	\[H = H \times \min(1.25, \max(1, \frac{a.Power}{b.Power})) \]

	<p>如果B是玩家，A是怪物，秒杀保护</p>
	\[H = \min(H, b.MaxHP \times 0.9 + 10) \]

	<p>伤害整体调低</p>
	\[H = H \times 0.35 \]

	<p>浮动伤害</p>
	\[H = H \times random(0.9,1.1) \]

	<p>如果受击方B是怪物，可以设置伤害上限</p>
	\[H = \min(H,b.MaxHP \times monster.maxsinglehitdamange \times 0.0001) \]

	<p>最终伤害数值</p>
	\[H = \max(1,H) \]


	<hr />







	<h1>开服关服</h1>
	<p>开服 Bin/Cluster/开服.bat</p>
	<p>关服 Bin/Cluster/关服.bat</p>
	<p class="explain">
		*
		AgentServer是网关服，客户端通过tcp与之通信；DBServer是数据服，负责缓存数据，与数据库交互；SceneServer场景服，游戏的业务逻辑都在这里。CenterServer是中心服，负责服务器之间的消息中转。
	</p>
	<hr />















	<h1>导航网格</h1>
	<p>美术制作Unity场景test.unity</p>
	<p>依据场景地表，用插件(NavMesh Exension)构建TerrainMesh</p>
	<p class="explain">
		* 美术制作的场景地表，与策划期望的寻路地表是有差异的，所以用该插件来构建更合理的TerrainMesh
	</p>
	<p>在插件(NavMesh Exension) Bake NavMesh，会生成该场景的导航文件test/NavMesh.asset</p>
	<p class="explain">
		* 根据该TerrainMesh，生成Unity的导航网格，用于引擎寻路
	</p>
	<p>点击Unity菜单->Zen->同步导航网格文件到服务器</p>
	<p class="explain">
		* 怪物AI的寻路，需要在服务器完成，根据Untiy的NavMesh生成tiles，用于服务器A*寻路（todo 服务器也需要改成NavMesh寻路）
	</p>
	<p>该场景的导航网格制作流程完毕，重启服务器，测试完毕后可提交svn</p>
	<p class="explain">
		* 先根据策划构建的TerrainMesh拾取顶点A，再NavMesh.SamplePosition将A变换到Navmesh上的顶点B，B就是Navigation
		的Destination
	</p>

	<hr />







	<h1>怪物</h1>
	<hr />







	<h1>AI</h1>
	<hr />







	<h1>美术制作规范</h1>
	<h2>3DMax</h2>
	<p>system unit metric -> meters，基本长度单位是米，例如角色身高两米</p>
	<p>骨骼动画的骨头(bone)尽可能的少</p>

	<h2>角色</h2>
	<p>纹理尺寸：512x512</p>
	<h2>怪物</h2>
	<h2>NPC</h2>
	<h2>坐骑</h2>
	<h2>UI</h2>
	<h2>场景</h2>
	unity在运行时加载的场景，有两种类型，一类是加入到File->Build Settings->Scenes In Build，出包前制作，不可热更；
	另一类是AssetBundle，无须加入到File->Build Settings->Scenes In Build，可以热更
	<h3>场景烘培Lighting</h3>
	场景添加灯光，烘焙之后，生成多张LightMap，场景里的GameObject的MeshRenderer组件包含Lighting Section，其属性Lightmap Static
	勾选，Lightmap Settings->Baked Lightmap
	<ul>
		<li>
			Lightmap
			<pre class="prettyprint">
class LightmapSettings{
public static LightmapData[] lightmaps;
}

</pre>
			<p>
				一个场景里面，会有0-65533(0xFFFE)个Lightmap，可为场景里面的所有的GameObject的Renderer组件公用，
				指定哪个Lightmap哪部分即可
			</p>
			<p></p>
		</li>
		<li>
			LightmapData
			<pre class="prettyprint">
	public sealed class LightmapData
	{
		// Summary:
		//     Lightmap storing color of incoming light.
		public Texture2D lightmapColor { get; set; }
		//
		// Summary:
		//     Lightmap storing dominant direction of incoming light.
		public Texture2D lightmapDir { get; set; }
		//
		// Summary:
		//     Texture storing occlusion mask per light (ShadowMask, up to four lights).
		public Texture2D shadowMask { get; set; }
	}
</pre>
			<p>
				Lightmap存储了三张Texture，分别存储了光的颜色、方向、阴影遮罩信息
			</p>
			<pre class="prettyprint">
// Decodes HDR textures
// handles dLDR, RGBM formats
inline half3 DecodeHDR (half4 data, half4 decodeInstructions)
{
	// If Linear mode is not supported we can skip exponent part
	#if defined(UNITY_NO_LINEAR_COLORSPACE)
		return (decodeInstructions.x * data.a) * data.rgb;
	#else
		return (decodeInstructions.x * pow(data.a, decodeInstructions.y)) * data.rgb;
	#endif
}
// Decodes doubleLDR encoded lightmaps.
inline half3 DecodeLightmapDoubleLDR( fixed4 color )
{
	return 2.0 * color.rgb;
}

inline half3 DecodeLightmapRGBM( fixed4 color )
{
	// potentially faster to do the scalar multiplication
	// in parenthesis for scalar GPUs
	return (LIGHTMAP_RGBM_SCALE * color.a) * color.rgb;
}
half4 unity_Lightmap_HDR;

inline half3 DecodeLightmap( fixed4 color )
{
#if defined(UNITY_NO_RGBM)
return DecodeLightmapDoubleLDR( color );
#else
return DecodeHDR( color, unity_Lightmap_HDR );
#endif
}
	  
// Platforms which do not use RGBM lightmap compression, or DXT5nm normal map compression
#if defined(SHADER_API_GLES) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL)
#define UNITY_NO_RGBM
#define UNITY_NO_DXT5nm
#endif

#if defined(SHADER_API_GLES) || defined(SHADER_API_GLES3) || defined(SHADER_API_METAL) || defined(SHADER_API_D3D11_9X) || defined(SHADER_API_PSP2)
#define UNITY_NO_LINEAR_COLORSPACE
#endif

// Lightmaps

// Main lightmap
UNITY_DECLARE_TEX2D(unity_Lightmap);
// Dual or directional lightmap (always used with unity_Lightmap, so can share sampler)
UNITY_DECLARE_TEX2D_NOSAMPLER(unity_LightmapInd);

// Dynamic GI lightmap
UNITY_DECLARE_TEX2D(unity_DynamicLightmap);
UNITY_DECLARE_TEX2D_NOSAMPLER(unity_DynamicDirectionality);
UNITY_DECLARE_TEX2D_NOSAMPLER(unity_DynamicNormal);

CBUFFER_START(UnityLightmaps)
	float4 unity_LightmapST;
	float4 unity_DynamicLightmapST;
CBUFFER_END 

#if defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
#define UNITY_DECLARE_TEX2D(tex) Texture2D tex; SamplerState sampler##tex
#define UNITY_DECLARE_TEX2D_NOSAMPLER(tex) Texture2D tex
#define UNITY_SAMPLE_TEX2D(tex,coord) tex.Sample (sampler##tex,coord)
#define UNITY_SAMPLE_TEX2D_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)
#define UNITY_DECLARE_TEXCUBE(tex) TextureCube tex; SamplerState sampler##tex
#define UNITY_ARGS_TEXCUBE(tex) TextureCube tex, SamplerState sampler##tex
#define UNITY_PASS_TEXCUBE(tex) tex, sampler##tex
#define UNITY_DECLARE_TEXCUBE_NOSAMPLER(tex) TextureCube tex
#define UNITY_SAMPLE_TEXCUBE(tex,coord) tex.Sample (sampler##tex,coord)
#define UNITY_SAMPLE_TEXCUBE_SAMPLER(tex,samplertex,coord) tex.Sample (sampler##samplertex,coord)
#else
#define UNITY_DECLARE_TEX2D(tex) sampler2D tex
#define UNITY_DECLARE_TEX2D_NOSAMPLER(tex) sampler2D tex
#define UNITY_SAMPLE_TEX2D(tex,coord) tex2D (tex,coord)
#define UNITY_SAMPLE_TEX2D_SAMPLER(tex,samplertex,coord) tex2D (tex,coord)
#define UNITY_DECLARE_TEXCUBE(tex) samplerCUBE tex
#define UNITY_ARGS_TEXCUBE(tex) samplerCUBE tex
#define UNITY_PASS_TEXCUBE(tex) tex
#define UNITY_DECLARE_TEXCUBE_NOSAMPLER(tex) samplerCUBE tex
#define UNITY_SAMPLE_TEXCUBE(tex,coord) texCUBE (tex,coord)
#define UNITY_SAMPLE_TEXCUBE_SAMPLER(tex,samplertex,coord) texCUBE (tex,coord)
#endif
 
// Transforms 2D UV by scale/bias property
#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw) 
</pre>
			<p></p>
		</li>
		<li>
			Lightmap Index
			<p>多张LIghtMap的索引，16位的整数，0-65533(0xFFFE)，-1 (0xFFFF)表示无</p>
			<p>GameObject.GetComponent<MeshRenderer>().lightmapIndex</p>
		</li>
	</ul>
	<h2>颜色空间</h2>
	<pre class="prettyprint">
	// From http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
inline half3 GammaToLinearSpace (half3 sRGB)
{
	return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);
}

inline half3 LinearToGammaSpace (half3 linRGB)
{
	return max(1.055 * pow(linRGB, 0.416666667) - 0.055, 0);
} 
</pre>
	<h2>Global Illumination</h2>
	全局光照，direct light + indirect light，即不仅考虑了直接光照，也考虑了间接光照（A物体反射光照到了B物体）
	间接光照非常耗时，仅可离线制作cg动画，或者静态烘焙，提前计算出间接光照，unity实现了此功能，称为Baked GI或者
	Baked Lightmaps，此外，还生成了软阴影soft shadow

	Precomputed Realtime GI.是上述Baked GI技术的升级，仍是离线制作，仍是针对静态物体，不同之处在于，记录了直接光的反射路径，
	光源的类型、位置、方向、颜色等参数在运行时皆可变。性能消耗也较高。

	<h2>Light Probe</h2>
	光照探头
	静态物体的反射光对运动物体的光照

	<h2>Ambient Occlusion(AO)</h2>
	渲染管线的光照模型，不论是phon-blin还是pbr，某物件渲染之时，只考虑光源与自身的几何关系，未考虑物件之间的遮挡
	Ambient Occlusion就是考虑这个遮挡对ambient的影响，常用方法有二：
	<h3>Screen Space Ambient Occlusion(SSAO)</h3>
	蒙特卡洛积分
	<img src="assets/image/ssao.png" />
	<h3>Horizon Based Ambient Occlusion(HBAO)</h3>
	<h2>phon</h2>
	<h2>blin-phon</h2>
	<h2>pbr</h2>
	<h2>贴花decal</h2>
	<h2>ICON</h2>
	<h2>宣传图</h2>
	<h2>特效</h2>
	<h1>Unity</h1>
	<h2>场景加载</h2>
	游戏工程启动时，第一个加载的场景是File->Build Settings->Scenes In Build里的第一个scene.unity文件（index为0），
	这个场景是自动加载的，完成热更和加载lua之后
	<pre class="prettyprint">
	--IWillAlwaysLoveYou
	private void Go()
	{
		gameObject.AddComponent<LuaMonoBehavior>().RunLuaFile("SceneManager");
	}

	public class LuaMonoBehavior : MonoBehaviour
	{
		public LuaTable RunLuaFile(string f)
		{
			LuaFile_ = f;
			if (ExecuteLuaFile())
			{
				CallLuaFunction("Awake");
				AutoRegister();
			}
			return LuaContext;
		}
	}
	function SceneManager.Awake()
		if GameLuaAPI.Channel == GameLuaAPI.eChannel.eChannel_None then
			SceneManager.LoadSceneWithLoading('LoginForm', true, false)
		else
			SceneManager.LoadSceneWithLoading('SelectZone', true, false)
		end
	end

function SceneManager.OnUpdate()
		SceneManager.asyncItem = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(SceneManager.curSceneName)
		SceneManager.asyncItem.allowSceneActivation = true
end
</pre>
	<h2>Transform</h2>
	transform组件的旋转是欧拉角，会产生万向锁，绕模型本地坐标系旋转
	<h2>Gimbal Lock</h2>
	万向节死锁
	本质在于旋转的次序，例如YXZ，首先绕惯性坐标系Y轴旋转，然后绕本地坐标系的X轴旋转，最后绕本地坐标系的Z轴旋转，
	如果本地坐标系的X轴或者Z轴与惯性坐标系的Y轴重合，那么绕本地坐标系X轴或者Z轴旋转等同于绕惯性坐标系Y轴旋转，即所谓的
	本地坐标系的X轴或者Z轴旋转失灵。每一次旋转，都是从初始角度开始旋转的！！！
	<h2>Quatation</h2>
	四元素
	<hr />

	<h1>LoginReward.csv</h1>
	累计登录奖励
	<pre class="prettyprint">
function LuaRequestGetLoginReward(actorID)
	local id = GetRequestNumberParam("id")
	local schemeItem = Schemes.LoginReward.Get(id)
	local gotFlag = Lua_GetLogicData(actorID, DATA_LOGINPRIZE_GOTFLAG)
	if _getbit(gotFlag, id) == 1 then
		return RESULT_COMMON_FAILURE
	end
	
	local totalDay = Lua_GetLogicData(actorID, DATA_LOGIN_TOTALDAYS)
	if totalDay < schemeItem.Day then
		return RESULT_COMMON_FAILURE
	end
	
	gotFlag = _setbit(gotFlag, id)
	Lua_SetLogicData(actorID, DATA_LOGINPRIZE_GOTFLAG, gotFlag)

	GivePrizeToPacket(actorID, schemeItem.PrizeID, RES_CREATE_LOGINREWARD, id, "登陆奖励")
	return RESULT_COMMON_SUCCEED
end

void CPlayer::SetTerminalTunnel(ITerminalTunnel* pTunnel)
{
	//累计登陆
	ILogicPart* pLogicPart = (ILogicPart*)GetEntityPart(PLAYER_PARTID_LOGIC);
	pLogicPart->SetLoginLogicData();
}

// 设置累计登陆的数据
void CLogicPart::SetLoginLogicData()
{
	IDateTime* pDateTime = Global->GetDateTime();
	int oldTime = m_arrLogicData[DATA_LOGIN_TIMES];
	int nLastResetTime = GetLogicData(DATA_LOGIN_TIMES);
	if (pDateTime->IsSameDay(ServerTime, nLastResetTime))
	{
		return;
	}

	BYTE byCanGetDays = GetLogicByte(DATA_LOGIN_GETTIME, 1);
	if (byCanGetDays < 30)
	{
		byCanGetDays += 1;
		DWORD dwValue = GetLogicData(DATA_LOGIN_GETTIME);
		dwValue &= ~(0xFF << (8 * 1));
		dwValue |= ((DWORD)byCanGetDays) << (8 * 1);
		m_arrLogicData[DATA_LOGIN_GETTIME] = dwValue;
	}
	int byTotalDays = GetLogicData(DATA_LOGIN_TOTALDAYS);
	byTotalDays += 1;
	m_arrLogicData[DATA_LOGIN_TOTALDAYS] = byTotalDays;
}
</pre>
	<footer>
		<address>
			written by LaoZhang.<br />
			297191409@qq.com.<br />
			ShenZhen<br />
			China
		</address>
	</footer>
</body>

</html>